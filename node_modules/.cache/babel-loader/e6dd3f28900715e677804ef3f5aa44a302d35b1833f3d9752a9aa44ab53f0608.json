{"ast":null,"code":"var _tabsEmits;\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { defineComponent, getCurrentInstance, ref, computed, watch, nextTick, provide, createVNode, renderSlot } from 'vue';\nimport '../../../utils/index.mjs';\nimport '../../../constants/index.mjs';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { Plus } from '@element-plus/icons-vue';\nimport '../../../hooks/index.mjs';\nimport { tabsRootContextKey } from './constants.mjs';\nimport TabNav from './tab-nav.mjs';\nimport { buildProps, definePropType } from '../../../utils/vue/props/runtime.mjs';\nimport { isString } from '@vue/shared';\nimport { isNumber, isUndefined } from '../../../utils/types.mjs';\nimport { UPDATE_MODEL_EVENT } from '../../../constants/event.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { useOrderedChildren } from '../../../hooks/use-ordered-children/index.mjs';\nimport { useDeprecated } from '../../../hooks/use-deprecated/index.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nvar tabsProps = buildProps({\n  type: {\n    type: String,\n    values: [\"card\", \"border-card\", \"\"],\n    \"default\": \"\"\n  },\n  activeName: {\n    type: [String, Number]\n  },\n  closable: Boolean,\n  addable: Boolean,\n  modelValue: {\n    type: [String, Number]\n  },\n  editable: Boolean,\n  tabPosition: {\n    type: String,\n    values: [\"top\", \"right\", \"bottom\", \"left\"],\n    \"default\": \"top\"\n  },\n  beforeLeave: {\n    type: definePropType(Function),\n    \"default\": function _default() {\n      return true;\n    }\n  },\n  stretch: Boolean\n});\nvar isPaneName = function isPaneName(value) {\n  return isString(value) || isNumber(value);\n};\nvar tabsEmits = (_tabsEmits = {}, _defineProperty(_tabsEmits, UPDATE_MODEL_EVENT, function (name) {\n  return isPaneName(name);\n}), _defineProperty(_tabsEmits, \"tabClick\", function tabClick(pane, ev) {\n  return ev instanceof Event;\n}), _defineProperty(_tabsEmits, \"tabChange\", function tabChange(name) {\n  return isPaneName(name);\n}), _defineProperty(_tabsEmits, \"edit\", function edit(paneName, action) {\n  return [\"remove\", \"add\"].includes(action);\n}), _defineProperty(_tabsEmits, \"tabRemove\", function tabRemove(name) {\n  return isPaneName(name);\n}), _defineProperty(_tabsEmits, \"tabAdd\", function tabAdd() {\n  return true;\n}), _tabsEmits);\nvar Tabs = defineComponent({\n  name: \"ElTabs\",\n  props: tabsProps,\n  emits: tabsEmits,\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit,\n      slots = _ref.slots,\n      expose = _ref.expose;\n    var _a, _b;\n    var ns = useNamespace(\"tabs\");\n    var _useOrderedChildren = useOrderedChildren(getCurrentInstance(), \"ElTabPane\"),\n      panes = _useOrderedChildren.children,\n      registerPane = _useOrderedChildren.addChild,\n      unregisterPane = _useOrderedChildren.removeChild;\n    var nav$ = ref();\n    var currentName = ref((_b = (_a = props.modelValue) != null ? _a : props.activeName) != null ? _b : \"0\");\n    var changeCurrentName = function changeCurrentName(value) {\n      currentName.value = value;\n      emit(UPDATE_MODEL_EVENT, value);\n      emit(\"tabChange\", value);\n    };\n    var setCurrentName = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(value) {\n        var _a2, _b2, _c, canLeave;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(currentName.value === value || isUndefined(value))) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              _context.prev = 2;\n              _context.next = 5;\n              return (_a2 = props.beforeLeave) == null ? void 0 : _a2.call(props, value, currentName.value);\n            case 5:\n              canLeave = _context.sent;\n              if (canLeave !== false) {\n                changeCurrentName(value);\n                (_c = (_b2 = nav$.value) == null ? void 0 : _b2.removeFocus) == null ? void 0 : _c.call(_b2);\n              }\n              _context.next = 11;\n              break;\n            case 9:\n              _context.prev = 9;\n              _context.t0 = _context[\"catch\"](2);\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[2, 9]]);\n      }));\n      return function setCurrentName(_x) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    var handleTabClick = function handleTabClick(tab, tabName, event) {\n      if (tab.props.disabled) return;\n      setCurrentName(tabName);\n      emit(\"tabClick\", tab, event);\n    };\n    var handleTabRemove = function handleTabRemove(pane, ev) {\n      if (pane.props.disabled || isUndefined(pane.props.name)) return;\n      ev.stopPropagation();\n      emit(\"edit\", pane.props.name, \"remove\");\n      emit(\"tabRemove\", pane.props.name);\n    };\n    var handleTabAdd = function handleTabAdd() {\n      emit(\"edit\", void 0, \"add\");\n      emit(\"tabAdd\");\n    };\n    useDeprecated({\n      from: '\"activeName\"',\n      replacement: '\"model-value\" or \"v-model\"',\n      scope: \"ElTabs\",\n      version: \"2.3.0\",\n      ref: \"https://element-plus.org/en-US/component/tabs.html#attributes\",\n      type: \"Attribute\"\n    }, computed(function () {\n      return !!props.activeName;\n    }));\n    watch(function () {\n      return props.activeName;\n    }, function (modelValue) {\n      return setCurrentName(modelValue);\n    });\n    watch(function () {\n      return props.modelValue;\n    }, function (modelValue) {\n      return setCurrentName(modelValue);\n    });\n    watch(currentName, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n      var _a2;\n      return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return nextTick();\n          case 2:\n            (_a2 = nav$.value) == null ? void 0 : _a2.scrollToActiveTab();\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2);\n    })));\n    provide(tabsRootContextKey, {\n      props: props,\n      currentName: currentName,\n      registerPane: registerPane,\n      unregisterPane: unregisterPane\n    });\n    expose({\n      currentName: currentName\n    });\n    return function () {\n      var _ref4;\n      var newButton = props.editable || props.addable ? createVNode(\"span\", {\n        \"class\": ns.e(\"new-tab\"),\n        \"tabindex\": \"0\",\n        \"onClick\": handleTabAdd,\n        \"onKeydown\": function onKeydown(ev) {\n          if (ev.code === EVENT_CODE.enter) handleTabAdd();\n        }\n      }, [createVNode(ElIcon, {\n        \"class\": ns.is(\"icon-plus\")\n      }, {\n        \"default\": function _default() {\n          return [createVNode(Plus, null, null)];\n        }\n      })]) : null;\n      var header = createVNode(\"div\", {\n        \"class\": [ns.e(\"header\"), ns.is(props.tabPosition)]\n      }, [newButton, createVNode(TabNav, {\n        \"ref\": nav$,\n        \"currentName\": currentName.value,\n        \"editable\": props.editable,\n        \"type\": props.type,\n        \"panes\": panes.value,\n        \"stretch\": props.stretch,\n        \"onTabClick\": handleTabClick,\n        \"onTabRemove\": handleTabRemove\n      }, null)]);\n      var panels = createVNode(\"div\", {\n        \"class\": ns.e(\"content\")\n      }, [renderSlot(slots, \"default\")]);\n      return createVNode(\"div\", {\n        \"class\": [ns.b(), ns.m(props.tabPosition), (_ref4 = {}, _defineProperty(_ref4, ns.m(\"card\"), props.type === \"card\"), _defineProperty(_ref4, ns.m(\"border-card\"), props.type === \"border-card\"), _ref4)]\n      }, _toConsumableArray(props.tabPosition !== \"bottom\" ? [header, panels] : [panels, header]));\n    };\n  }\n});\nexport { Tabs as default, tabsEmits, tabsProps };","map":{"version":3,"names":["tabsProps","buildProps","type","String","values","activeName","Number","closable","Boolean","addable","modelValue","editable","tabPosition","beforeLeave","definePropType","Function","_default","stretch","tabsEmits","_tabsEmits","_defineProperty","tabClick","pane","ev","Event","tabChange","name","isPaneName","edit","paneName","action","includes","tabRemove","tabAdd","Tabs","defineComponent","props","emits","setup","_ref","emit","expose","_a","_b","ns","useNamespace","_useOrderedChildren","useOrderedChildren","getCurrentInstance","panes","children","registerPane","addChild","unregisterPane","removeChild","nav$","ref","currentName","changeCurrentName","value","setCurrentName","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","_a2","_b2","_c","canLeave","wrap","_callee$","_context","prev","next","isUndefined","abrupt","call","sent","removeFocus","t0","stop","_x","apply","arguments","handleTabClick","tab","tabName","event","disabled","handleTabRemove","stopPropagation","from","replacement","version","computed","watch","_callee2","_callee2$","_context2","nextTick","scrollToActiveTab","provide","tabsRootContextKey","_ref4","newButton","createVNode","e","handleTabAdd","onKeydown","code","EVENT_CODE","enter","ElIcon","is","Plus","header","TabNav","panels","renderSlot","slots","b","m","_toConsumableArray"],"sources":["../../../../../../packages/components/tabs/src/tabs.tsx"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  nextTick,\n  provide,\n  ref,\n  renderSlot,\n  watch,\n} from 'vue'\nimport {\n  buildProps,\n  definePropType,\n  isNumber,\n  isString,\n  isUndefined,\n} from '@element-plus/utils'\nimport { EVENT_CODE, UPDATE_MODEL_EVENT } from '@element-plus/constants'\nimport ElIcon from '@element-plus/components/icon'\nimport { Plus } from '@element-plus/icons-vue'\nimport {\n  useDeprecated,\n  useNamespace,\n  useOrderedChildren,\n} from '@element-plus/hooks'\nimport { tabsRootContextKey } from './constants'\nimport TabNav from './tab-nav'\n\nimport type { TabNavInstance } from './tab-nav'\nimport type { TabsPaneContext } from './constants'\nimport type { ExtractPropTypes } from 'vue'\nimport type { Awaitable } from '@element-plus/utils'\n\nexport type TabPaneName = string | number\n\nexport const tabsProps = buildProps({\n  type: {\n    type: String,\n    values: ['card', 'border-card', ''],\n    default: '',\n  },\n  activeName: {\n    type: [String, Number],\n  },\n  closable: Boolean,\n  addable: Boolean,\n  modelValue: {\n    type: [String, Number],\n  },\n  editable: Boolean,\n  tabPosition: {\n    type: String,\n    values: ['top', 'right', 'bottom', 'left'],\n    default: 'top',\n  },\n  beforeLeave: {\n    type: definePropType<\n      (newName: TabPaneName, oldName: TabPaneName) => Awaitable<void | boolean>\n    >(Function),\n    default: () => true,\n  },\n  stretch: Boolean,\n} as const)\nexport type TabsProps = ExtractPropTypes<typeof tabsProps>\n\nconst isPaneName = (value: unknown): value is string | number =>\n  isString(value) || isNumber(value)\n\nexport const tabsEmits = {\n  [UPDATE_MODEL_EVENT]: (name: TabPaneName) => isPaneName(name),\n  tabClick: (pane: TabsPaneContext, ev: Event) => ev instanceof Event,\n  tabChange: (name: TabPaneName) => isPaneName(name),\n  edit: (paneName: TabPaneName | undefined, action: 'remove' | 'add') =>\n    ['remove', 'add'].includes(action),\n  tabRemove: (name: TabPaneName) => isPaneName(name),\n  tabAdd: () => true,\n}\nexport type TabsEmits = typeof tabsEmits\n\nexport type TabsPanes = Record<number, TabsPaneContext>\n\nexport default defineComponent({\n  name: 'ElTabs',\n\n  props: tabsProps,\n  emits: tabsEmits,\n\n  setup(props, { emit, slots, expose }) {\n    const ns = useNamespace('tabs')\n\n    const {\n      children: panes,\n      addChild: registerPane,\n      removeChild: unregisterPane,\n    } = useOrderedChildren<TabsPaneContext>(getCurrentInstance()!, 'ElTabPane')\n\n    const nav$ = ref<TabNavInstance>()\n    const currentName = ref<TabPaneName>(\n      props.modelValue ?? props.activeName ?? '0'\n    )\n\n    const changeCurrentName = (value: TabPaneName) => {\n      currentName.value = value\n      emit(UPDATE_MODEL_EVENT, value)\n      emit('tabChange', value)\n    }\n\n    const setCurrentName = async (value?: TabPaneName) => {\n      // should do nothing.\n      if (currentName.value === value || isUndefined(value)) return\n\n      try {\n        const canLeave = await props.beforeLeave?.(value, currentName.value)\n        if (canLeave !== false) {\n          changeCurrentName(value)\n\n          // call exposed function, Vue doesn't support expose in typescript yet.\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-expect-error\n          nav$.value?.removeFocus?.()\n        }\n      } catch {}\n    }\n\n    const handleTabClick = (\n      tab: TabsPaneContext,\n      tabName: TabPaneName,\n      event: Event\n    ) => {\n      if (tab.props.disabled) return\n      setCurrentName(tabName)\n      emit('tabClick', tab, event)\n    }\n\n    const handleTabRemove = (pane: TabsPaneContext, ev: Event) => {\n      if (pane.props.disabled || isUndefined(pane.props.name)) return\n      ev.stopPropagation()\n      emit('edit', pane.props.name, 'remove')\n      emit('tabRemove', pane.props.name)\n    }\n\n    const handleTabAdd = () => {\n      emit('edit', undefined, 'add')\n      emit('tabAdd')\n    }\n\n    useDeprecated(\n      {\n        from: '\"activeName\"',\n        replacement: '\"model-value\" or \"v-model\"',\n        scope: 'ElTabs',\n        version: '2.3.0',\n        ref: 'https://element-plus.org/en-US/component/tabs.html#attributes',\n        type: 'Attribute',\n      },\n      computed(() => !!props.activeName)\n    )\n\n    watch(\n      () => props.activeName,\n      (modelValue) => setCurrentName(modelValue)\n    )\n\n    watch(\n      () => props.modelValue,\n      (modelValue) => setCurrentName(modelValue)\n    )\n\n    watch(currentName, async () => {\n      await nextTick()\n      // call exposed function, Vue doesn't support expose in typescript yet.\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-expect-error\n      nav$.value?.scrollToActiveTab()\n    })\n\n    provide(tabsRootContextKey, {\n      props,\n      currentName,\n      registerPane,\n      unregisterPane,\n    })\n\n    expose({\n      currentName,\n    })\n\n    return () => {\n      const newButton =\n        props.editable || props.addable ? (\n          <span\n            class={ns.e('new-tab')}\n            tabindex=\"0\"\n            onClick={handleTabAdd}\n            onKeydown={(ev: KeyboardEvent) => {\n              if (ev.code === EVENT_CODE.enter) handleTabAdd()\n            }}\n          >\n            <ElIcon class={ns.is('icon-plus')}>\n              <Plus />\n            </ElIcon>\n          </span>\n        ) : null\n\n      const header = (\n        <div class={[ns.e('header'), ns.is(props.tabPosition)]}>\n          {newButton}\n          <TabNav\n            ref={nav$}\n            currentName={currentName.value}\n            editable={props.editable}\n            type={props.type}\n            panes={panes.value}\n            stretch={props.stretch}\n            onTabClick={handleTabClick}\n            onTabRemove={handleTabRemove}\n          />\n        </div>\n      )\n\n      const panels = (\n        <div class={ns.e('content')}>{renderSlot(slots, 'default')}</div>\n      )\n\n      return (\n        <div\n          class={[\n            ns.b(),\n            ns.m(props.tabPosition),\n            {\n              [ns.m('card')]: props.type === 'card',\n              [ns.m('border-card')]: props.type === 'border-card',\n            },\n          ]}\n        >\n          {...props.tabPosition !== 'bottom'\n            ? [header, panels]\n            : [panels, header]}\n        </div>\n      )\n    }\n  },\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}