{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nimport { defineComponent, ref, provide, watch, unref, nextTick, onMounted, onBeforeUnmount, renderSlot } from 'vue';\nimport { isNil } from 'lodash-unified';\nimport '../../../constants/index.mjs';\nimport '../../../hooks/index.mjs';\nimport '../../../utils/index.mjs';\nimport { useFocusReason, getEdges, createFocusOutPreventedEvent, tryFocus, focusableStack, focusFirstDescendant, obtainAllFocusableElements, isFocusCausedByUserEvent } from './utils.mjs';\nimport { ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, FOCUS_TRAP_INJECTION_KEY, FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS, FOCUS_AFTER_RELEASED } from './tokens.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useEscapeKeydown } from '../../../hooks/use-escape-keydown/index.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { isString } from '@vue/shared';\nvar _sfc_main = defineComponent({\n  name: \"ElFocusTrap\",\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object,\n    focusStartEl: {\n      type: [Object, String],\n      \"default\": \"first\"\n    }\n  },\n  emits: [ON_TRAP_FOCUS_EVT, ON_RELEASE_FOCUS_EVT, \"focusin\", \"focusout\", \"focusout-prevented\", \"release-requested\"],\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit;\n    var forwardRef = ref();\n    var lastFocusBeforeTrapped;\n    var lastFocusAfterTrapped;\n    var _useFocusReason = useFocusReason(),\n      focusReason = _useFocusReason.focusReason;\n    useEscapeKeydown(function (event) {\n      if (props.trapped && !focusLayer.paused) {\n        emit(\"release-requested\", event);\n      }\n    });\n    var focusLayer = {\n      paused: false,\n      pause: function pause() {\n        this.paused = true;\n      },\n      resume: function resume() {\n        this.paused = false;\n      }\n    };\n    var onKeydown = function onKeydown(e) {\n      if (!props.loop && !props.trapped) return;\n      if (focusLayer.paused) return;\n      var key = e.key,\n        altKey = e.altKey,\n        ctrlKey = e.ctrlKey,\n        metaKey = e.metaKey,\n        currentTarget = e.currentTarget,\n        shiftKey = e.shiftKey;\n      var loop = props.loop;\n      var isTabbing = key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey;\n      var currentFocusingEl = document.activeElement;\n      if (isTabbing && currentFocusingEl) {\n        var container = currentTarget;\n        var _getEdges = getEdges(container),\n          _getEdges2 = _slicedToArray(_getEdges, 2),\n          first = _getEdges2[0],\n          last = _getEdges2[1];\n        var isTabbable = first && last;\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            var focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", focusoutPreventedEvent);\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n            }\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            var _focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", _focusoutPreventedEvent);\n            if (!_focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault();\n              if (loop) tryFocus(first, true);\n            }\n          } else if (shiftKey && [first, container].includes(currentFocusingEl)) {\n            var _focusoutPreventedEvent2 = createFocusOutPreventedEvent({\n              focusReason: focusReason.value\n            });\n            emit(\"focusout-prevented\", _focusoutPreventedEvent2);\n            if (!_focusoutPreventedEvent2.defaultPrevented) {\n              e.preventDefault();\n              if (loop) tryFocus(last, true);\n            }\n          }\n        }\n      }\n    };\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown: onKeydown\n    });\n    watch(function () {\n      return props.focusTrapEl;\n    }, function (focusTrapEl) {\n      if (focusTrapEl) {\n        forwardRef.value = focusTrapEl;\n      }\n    }, {\n      immediate: true\n    });\n    watch([forwardRef], function (_ref2, _ref3) {\n      var _ref4 = _slicedToArray(_ref2, 1),\n        forwardRef2 = _ref4[0];\n      var _ref5 = _slicedToArray(_ref3, 1),\n        oldForwardRef = _ref5[0];\n      if (forwardRef2) {\n        forwardRef2.addEventListener(\"keydown\", onKeydown);\n        forwardRef2.addEventListener(\"focusin\", onFocusIn);\n        forwardRef2.addEventListener(\"focusout\", onFocusOut);\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener(\"keydown\", onKeydown);\n        oldForwardRef.removeEventListener(\"focusin\", onFocusIn);\n        oldForwardRef.removeEventListener(\"focusout\", onFocusOut);\n      }\n    });\n    var trapOnFocus = function trapOnFocus(e) {\n      emit(ON_TRAP_FOCUS_EVT, e);\n    };\n    var releaseOnFocus = function releaseOnFocus(e) {\n      return emit(ON_RELEASE_FOCUS_EVT, e);\n    };\n    var onFocusIn = function onFocusIn(e) {\n      var trapContainer = unref(forwardRef);\n      if (!trapContainer) return;\n      var target = e.target;\n      var relatedTarget = e.relatedTarget;\n      var isFocusedInTrap = target && trapContainer.contains(target);\n      if (!props.trapped) {\n        var isPrevFocusedInTrap = relatedTarget && trapContainer.contains(relatedTarget);\n        if (!isPrevFocusedInTrap) {\n          lastFocusBeforeTrapped = relatedTarget;\n        }\n      }\n      if (isFocusedInTrap) emit(\"focusin\", e);\n      if (focusLayer.paused) return;\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target;\n        } else {\n          tryFocus(lastFocusAfterTrapped, true);\n        }\n      }\n    };\n    var onFocusOut = function onFocusOut(e) {\n      var trapContainer = unref(forwardRef);\n      if (focusLayer.paused || !trapContainer) return;\n      if (props.trapped) {\n        var relatedTarget = e.relatedTarget;\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          setTimeout(function () {\n            if (!focusLayer.paused && props.trapped) {\n              var focusoutPreventedEvent = createFocusOutPreventedEvent({\n                focusReason: focusReason.value\n              });\n              emit(\"focusout-prevented\", focusoutPreventedEvent);\n              if (!focusoutPreventedEvent.defaultPrevented) {\n                tryFocus(lastFocusAfterTrapped, true);\n              }\n            }\n          }, 0);\n        }\n      } else {\n        var target = e.target;\n        var isFocusedInTrap = target && trapContainer.contains(target);\n        if (!isFocusedInTrap) emit(\"focusout\", e);\n      }\n    };\n    function startTrap() {\n      return _startTrap.apply(this, arguments);\n    }\n    function _startTrap() {\n      _startTrap = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var trapContainer, prevFocusedElement, isPrevFocusContained, focusEvent;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return nextTick();\n            case 2:\n              trapContainer = unref(forwardRef);\n              if (trapContainer) {\n                focusableStack.push(focusLayer);\n                prevFocusedElement = trapContainer.contains(document.activeElement) ? lastFocusBeforeTrapped : document.activeElement;\n                lastFocusBeforeTrapped = prevFocusedElement;\n                isPrevFocusContained = trapContainer.contains(prevFocusedElement);\n                if (!isPrevFocusContained) {\n                  focusEvent = new Event(FOCUS_AFTER_TRAPPED, FOCUS_AFTER_TRAPPED_OPTS);\n                  trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n                  trapContainer.dispatchEvent(focusEvent);\n                  if (!focusEvent.defaultPrevented) {\n                    nextTick(function () {\n                      var focusStartEl = props.focusStartEl;\n                      if (!isString(focusStartEl)) {\n                        tryFocus(focusStartEl);\n                        if (document.activeElement !== focusStartEl) {\n                          focusStartEl = \"first\";\n                        }\n                      }\n                      if (focusStartEl === \"first\") {\n                        focusFirstDescendant(obtainAllFocusableElements(trapContainer), true);\n                      }\n                      if (document.activeElement === prevFocusedElement || focusStartEl === \"container\") {\n                        tryFocus(trapContainer);\n                      }\n                    });\n                  }\n                }\n              }\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return _startTrap.apply(this, arguments);\n    }\n    function stopTrap() {\n      var trapContainer = unref(forwardRef);\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus);\n        var releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, _objectSpread(_objectSpread({}, FOCUS_AFTER_TRAPPED_OPTS), {}, {\n          detail: {\n            focusReason: focusReason.value\n          }\n        }));\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus);\n        trapContainer.dispatchEvent(releasedEvent);\n        if (!releasedEvent.defaultPrevented && (focusReason.value == \"keyboard\" || !isFocusCausedByUserEvent() || trapContainer.contains(document.activeElement))) {\n          tryFocus(lastFocusBeforeTrapped != null ? lastFocusBeforeTrapped : document.body);\n        }\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus);\n        focusableStack.remove(focusLayer);\n      }\n    }\n    onMounted(function () {\n      if (props.trapped) {\n        startTrap();\n      }\n      watch(function () {\n        return props.trapped;\n      }, function (trapped) {\n        if (trapped) {\n          startTrap();\n        } else {\n          stopTrap();\n        }\n      });\n    });\n    onBeforeUnmount(function () {\n      if (props.trapped) {\n        stopTrap();\n      }\n    });\n    return {\n      onKeydown: onKeydown\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return renderSlot(_ctx.$slots, \"default\", {\n    handleKeydown: _ctx.onKeydown\n  });\n}\nvar ElFocusTrap = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/focus-trap/src/focus-trap.vue\"]]);\nexport { ElFocusTrap as default };","map":{"version":3,"names":["_sfc_main","defineComponent","name","inheritAttrs","props","loop","Boolean","trapped","focusTrapEl","Object","focusStartEl","type","String","emits","ON_TRAP_FOCUS_EVT","ON_RELEASE_FOCUS_EVT","setup","_ref","emit","forwardRef","ref","lastFocusBeforeTrapped","lastFocusAfterTrapped","_useFocusReason","useFocusReason","focusReason","useEscapeKeydown","event","focusLayer","paused","pause","resume","onKeydown","e","key","altKey","ctrlKey","metaKey","currentTarget","shiftKey","isTabbing","EVENT_CODE","tab","currentFocusingEl","document","activeElement","container","_getEdges","getEdges","_getEdges2","_slicedToArray","first","last","isTabbable","focusoutPreventedEvent","createFocusOutPreventedEvent","value","defaultPrevented","preventDefault","tryFocus","includes","provide","FOCUS_TRAP_INJECTION_KEY","focusTrapRef","watch","immediate","_ref2","_ref3","_ref4","forwardRef2","_ref5","oldForwardRef","addEventListener","onFocusIn","onFocusOut","removeEventListener","trapOnFocus","releaseOnFocus","trapContainer","unref","target","relatedTarget","isFocusedInTrap","contains","isPrevFocusedInTrap","isNil","setTimeout","startTrap","_startTrap","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","prevFocusedElement","isPrevFocusContained","focusEvent","wrap","_callee$","_context","prev","next","nextTick","focusableStack","push","Event","FOCUS_AFTER_TRAPPED","FOCUS_AFTER_TRAPPED_OPTS","dispatchEvent","isString","focusFirstDescendant","obtainAllFocusableElements","stop","stopTrap","releasedEvent","CustomEvent","FOCUS_AFTER_RELEASED","_objectSpread","detail","isFocusCausedByUserEvent","body","remove","onMounted","onBeforeUnmount","renderSlot","_ctx","$slots","handleKeydown"],"sources":["../../../../../../packages/components/focus-trap/src/focus-trap.vue"],"sourcesContent":["<template>\n  <slot :handle-keydown=\"onKeydown\" />\n</template>\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  ref,\n  unref,\n  watch,\n} from 'vue'\nimport { isNil } from 'lodash-unified'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { useEscapeKeydown } from '@element-plus/hooks'\nimport { isString } from '@element-plus/utils'\nimport {\n  createFocusOutPreventedEvent,\n  focusFirstDescendant,\n  focusableStack,\n  getEdges,\n  isFocusCausedByUserEvent,\n  obtainAllFocusableElements,\n  tryFocus,\n  useFocusReason,\n} from './utils'\nimport {\n  FOCUS_AFTER_RELEASED,\n  FOCUS_AFTER_TRAPPED,\n  FOCUS_AFTER_TRAPPED_OPTS,\n  FOCUS_TRAP_INJECTION_KEY,\n  ON_RELEASE_FOCUS_EVT,\n  ON_TRAP_FOCUS_EVT,\n} from './tokens'\n\nimport type { PropType } from 'vue'\nimport type { FocusLayer } from './utils'\n\nexport default defineComponent({\n  name: 'ElFocusTrap',\n  inheritAttrs: false,\n  props: {\n    loop: Boolean,\n    trapped: Boolean,\n    focusTrapEl: Object as PropType<HTMLElement>,\n    focusStartEl: {\n      type: [Object, String] as PropType<'container' | 'first' | HTMLElement>,\n      default: 'first',\n    },\n  },\n  emits: [\n    ON_TRAP_FOCUS_EVT,\n    ON_RELEASE_FOCUS_EVT,\n    'focusin',\n    'focusout',\n    'focusout-prevented',\n    'release-requested',\n  ],\n  setup(props, { emit }) {\n    const forwardRef = ref<HTMLElement | undefined>()\n    let lastFocusBeforeTrapped: HTMLElement | null\n    let lastFocusAfterTrapped: HTMLElement | null\n\n    const { focusReason } = useFocusReason()\n\n    useEscapeKeydown((event) => {\n      if (props.trapped && !focusLayer.paused) {\n        emit('release-requested', event)\n      }\n    })\n\n    const focusLayer: FocusLayer = {\n      paused: false,\n      pause() {\n        this.paused = true\n      },\n      resume() {\n        this.paused = false\n      },\n    }\n\n    const onKeydown = (e: KeyboardEvent) => {\n      if (!props.loop && !props.trapped) return\n      if (focusLayer.paused) return\n\n      const { key, altKey, ctrlKey, metaKey, currentTarget, shiftKey } = e\n      const { loop } = props\n      const isTabbing =\n        key === EVENT_CODE.tab && !altKey && !ctrlKey && !metaKey\n\n      const currentFocusingEl = document.activeElement\n      if (isTabbing && currentFocusingEl) {\n        const container = currentTarget as HTMLElement\n        const [first, last] = getEdges(container)\n        const isTabbable = first && last\n        if (!isTabbable) {\n          if (currentFocusingEl === container) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n            }\n          }\n        } else {\n          if (!shiftKey && currentFocusingEl === last) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n              if (loop) tryFocus(first, true)\n            }\n          } else if (\n            shiftKey &&\n            [first, container].includes(currentFocusingEl as HTMLElement)\n          ) {\n            const focusoutPreventedEvent = createFocusOutPreventedEvent({\n              focusReason: focusReason.value,\n            })\n            emit('focusout-prevented', focusoutPreventedEvent)\n            if (!focusoutPreventedEvent.defaultPrevented) {\n              e.preventDefault()\n              if (loop) tryFocus(last, true)\n            }\n          }\n        }\n      }\n    }\n\n    provide(FOCUS_TRAP_INJECTION_KEY, {\n      focusTrapRef: forwardRef,\n      onKeydown,\n    })\n\n    watch(\n      () => props.focusTrapEl,\n      (focusTrapEl) => {\n        if (focusTrapEl) {\n          forwardRef.value = focusTrapEl\n        }\n      },\n      { immediate: true }\n    )\n\n    watch([forwardRef], ([forwardRef], [oldForwardRef]) => {\n      if (forwardRef) {\n        forwardRef.addEventListener('keydown', onKeydown)\n        forwardRef.addEventListener('focusin', onFocusIn)\n        forwardRef.addEventListener('focusout', onFocusOut)\n      }\n      if (oldForwardRef) {\n        oldForwardRef.removeEventListener('keydown', onKeydown)\n        oldForwardRef.removeEventListener('focusin', onFocusIn)\n        oldForwardRef.removeEventListener('focusout', onFocusOut)\n      }\n    })\n\n    const trapOnFocus = (e: Event) => {\n      emit(ON_TRAP_FOCUS_EVT, e)\n    }\n    const releaseOnFocus = (e: Event) => emit(ON_RELEASE_FOCUS_EVT, e)\n\n    const onFocusIn = (e: FocusEvent) => {\n      const trapContainer = unref(forwardRef)\n      if (!trapContainer) return\n\n      const target = e.target as HTMLElement | null\n      const relatedTarget = e.relatedTarget as HTMLElement | null\n      const isFocusedInTrap = target && trapContainer.contains(target)\n\n      if (!props.trapped) {\n        const isPrevFocusedInTrap =\n          relatedTarget && trapContainer.contains(relatedTarget)\n        if (!isPrevFocusedInTrap) {\n          lastFocusBeforeTrapped = relatedTarget\n        }\n      }\n\n      if (isFocusedInTrap) emit('focusin', e)\n\n      if (focusLayer.paused) return\n\n      if (props.trapped) {\n        if (isFocusedInTrap) {\n          lastFocusAfterTrapped = target\n        } else {\n          tryFocus(lastFocusAfterTrapped, true)\n        }\n      }\n    }\n\n    const onFocusOut = (e: Event) => {\n      const trapContainer = unref(forwardRef)\n      if (focusLayer.paused || !trapContainer) return\n\n      if (props.trapped) {\n        const relatedTarget = (e as FocusEvent)\n          .relatedTarget as HTMLElement | null\n        if (!isNil(relatedTarget) && !trapContainer.contains(relatedTarget)) {\n          // Give embedded focus layer time to pause this layer before reclaiming focus\n          // And only reclaim focus if it should currently be trapping\n          setTimeout(() => {\n            if (!focusLayer.paused && props.trapped) {\n              const focusoutPreventedEvent = createFocusOutPreventedEvent({\n                focusReason: focusReason.value,\n              })\n              emit('focusout-prevented', focusoutPreventedEvent)\n              if (!focusoutPreventedEvent.defaultPrevented) {\n                tryFocus(lastFocusAfterTrapped, true)\n              }\n            }\n          }, 0)\n        }\n      } else {\n        const target = e.target as HTMLElement | null\n        const isFocusedInTrap = target && trapContainer.contains(target)\n        if (!isFocusedInTrap) emit('focusout', e)\n      }\n    }\n\n    async function startTrap() {\n      // Wait for forwardRef to resolve\n      await nextTick()\n      const trapContainer = unref(forwardRef)\n      if (trapContainer) {\n        focusableStack.push(focusLayer)\n        const prevFocusedElement = trapContainer.contains(\n          document.activeElement\n        )\n          ? lastFocusBeforeTrapped\n          : document.activeElement\n        lastFocusBeforeTrapped = prevFocusedElement as HTMLElement | null\n        const isPrevFocusContained = trapContainer.contains(prevFocusedElement)\n        if (!isPrevFocusContained) {\n          const focusEvent = new Event(\n            FOCUS_AFTER_TRAPPED,\n            FOCUS_AFTER_TRAPPED_OPTS\n          )\n          trapContainer.addEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n          trapContainer.dispatchEvent(focusEvent)\n          if (!focusEvent.defaultPrevented) {\n            nextTick(() => {\n              let focusStartEl = props.focusStartEl\n              if (!isString(focusStartEl)) {\n                tryFocus(focusStartEl)\n                if (document.activeElement !== focusStartEl) {\n                  focusStartEl = 'first'\n                }\n              }\n              if (focusStartEl === 'first') {\n                focusFirstDescendant(\n                  obtainAllFocusableElements(trapContainer),\n                  true\n                )\n              }\n              if (\n                document.activeElement === prevFocusedElement ||\n                focusStartEl === 'container'\n              ) {\n                tryFocus(trapContainer)\n              }\n            })\n          }\n        }\n      }\n    }\n\n    function stopTrap() {\n      const trapContainer = unref(forwardRef)\n\n      if (trapContainer) {\n        trapContainer.removeEventListener(FOCUS_AFTER_TRAPPED, trapOnFocus)\n\n        const releasedEvent = new CustomEvent(FOCUS_AFTER_RELEASED, {\n          ...FOCUS_AFTER_TRAPPED_OPTS,\n          detail: {\n            focusReason: focusReason.value,\n          },\n        })\n        trapContainer.addEventListener(FOCUS_AFTER_RELEASED, releaseOnFocus)\n        trapContainer.dispatchEvent(releasedEvent)\n        if (\n          !releasedEvent.defaultPrevented &&\n          (focusReason.value == 'keyboard' ||\n            !isFocusCausedByUserEvent() ||\n            trapContainer.contains(document.activeElement))\n        ) {\n          tryFocus(lastFocusBeforeTrapped ?? document.body)\n        }\n\n        trapContainer.removeEventListener(FOCUS_AFTER_RELEASED, trapOnFocus)\n        focusableStack.remove(focusLayer)\n      }\n    }\n\n    onMounted(() => {\n      if (props.trapped) {\n        startTrap()\n      }\n\n      watch(\n        () => props.trapped,\n        (trapped) => {\n          if (trapped) {\n            startTrap()\n          } else {\n            stopTrap()\n          }\n        }\n      )\n    })\n\n    onBeforeUnmount(() => {\n      if (props.trapped) {\n        stopTrap()\n      }\n    })\n\n    return {\n      onKeydown,\n    }\n  },\n})\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}