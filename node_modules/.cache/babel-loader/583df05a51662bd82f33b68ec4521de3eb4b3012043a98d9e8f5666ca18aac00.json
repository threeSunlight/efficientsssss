{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct.bind(); } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nimport { isNil } from 'lodash-unified';\nimport '../../../utils/index.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nvar SCOPE = \"ElUpload\";\nvar UploadAjaxError = /*#__PURE__*/function (_Error) {\n  _inherits(UploadAjaxError, _Error);\n  var _super = _createSuper(UploadAjaxError);\n  function UploadAjaxError(message, status, method, url) {\n    var _this;\n    _classCallCheck(this, UploadAjaxError);\n    _this = _super.call(this, message);\n    _this.name = \"UploadAjaxError\";\n    _this.status = status;\n    _this.method = method;\n    _this.url = url;\n    return _this;\n  }\n  return _createClass(UploadAjaxError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nfunction getError(action, option, xhr) {\n  var msg;\n  if (xhr.response) {\n    msg = \"\".concat(xhr.response.error || xhr.response);\n  } else if (xhr.responseText) {\n    msg = \"\".concat(xhr.responseText);\n  } else {\n    msg = \"fail to \".concat(option.method, \" \").concat(action, \" \").concat(xhr.status);\n  }\n  return new UploadAjaxError(msg, xhr.status, option.method, action);\n}\nfunction getBody(xhr) {\n  var text = xhr.responseText || xhr.response;\n  if (!text) {\n    return text;\n  }\n  try {\n    return JSON.parse(text);\n  } catch (e) {\n    return text;\n  }\n}\nvar ajaxUpload = function ajaxUpload(option) {\n  if (typeof XMLHttpRequest === \"undefined\") throwError(SCOPE, \"XMLHttpRequest is undefined\");\n  var xhr = new XMLHttpRequest();\n  var action = option.action;\n  if (xhr.upload) {\n    xhr.upload.addEventListener(\"progress\", function (evt) {\n      var progressEvt = evt;\n      progressEvt.percent = evt.total > 0 ? evt.loaded / evt.total * 100 : 0;\n      option.onProgress(progressEvt);\n    });\n  }\n  var formData = new FormData();\n  if (option.data) {\n    for (var _i = 0, _Object$entries = Object.entries(option.data); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        key = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n      if (Array.isArray(value)) formData.append.apply(formData, [key].concat(_toConsumableArray(value)));else formData.append(key, value);\n    }\n  }\n  formData.append(option.filename, option.file, option.file.name);\n  xhr.addEventListener(\"error\", function () {\n    option.onError(getError(action, option, xhr));\n  });\n  xhr.addEventListener(\"load\", function () {\n    if (xhr.status < 200 || xhr.status >= 300) {\n      return option.onError(getError(action, option, xhr));\n    }\n    option.onSuccess(getBody(xhr));\n  });\n  xhr.open(option.method, action, true);\n  if (option.withCredentials && \"withCredentials\" in xhr) {\n    xhr.withCredentials = true;\n  }\n  var headers = option.headers || {};\n  if (headers instanceof Headers) {\n    headers.forEach(function (value, key) {\n      return xhr.setRequestHeader(key, value);\n    });\n  } else {\n    for (var _i2 = 0, _Object$entries2 = Object.entries(headers); _i2 < _Object$entries2.length; _i2++) {\n      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n        _key = _Object$entries2$_i[0],\n        _value = _Object$entries2$_i[1];\n      if (isNil(_value)) continue;\n      xhr.setRequestHeader(_key, String(_value));\n    }\n  }\n  xhr.send(formData);\n  return xhr;\n};\nexport { UploadAjaxError, ajaxUpload };","map":{"version":3,"names":["SCOPE","UploadAjaxError","_Error","_inherits","_super","_createSuper","message","status","method","url","_this","_classCallCheck","call","name","_createClass","_wrapNativeSuper","Error","getError","action","option","xhr","msg","response","concat","error","responseText","getBody","text","JSON","parse","e","ajaxUpload","XMLHttpRequest","throwError","upload","addEventListener","evt","progressEvt","percent","total","loaded","onProgress","formData","FormData","data","_i","_Object$entries","Object","entries","length","_Object$entries$_i","_slicedToArray","key","value","Array","isArray","append","apply","_toConsumableArray","filename","file","onError","onSuccess","open","withCredentials","headers","Headers","forEach","setRequestHeader","_i2","_Object$entries2","_Object$entries2$_i","isNil","String","send"],"sources":["../../../../../../packages/components/upload/src/ajax.ts"],"sourcesContent":["import { isNil } from 'lodash-unified'\nimport { throwError } from '@element-plus/utils'\nimport type {\n  UploadProgressEvent,\n  UploadRequestHandler,\n  UploadRequestOptions,\n} from './upload'\n\nconst SCOPE = 'ElUpload'\n\nexport class UploadAjaxError extends Error {\n  name = 'UploadAjaxError'\n  status: number\n  method: string\n  url: string\n\n  constructor(message: string, status: number, method: string, url: string) {\n    super(message)\n    this.status = status\n    this.method = method\n    this.url = url\n  }\n}\n\nfunction getError(\n  action: string,\n  option: UploadRequestOptions,\n  xhr: XMLHttpRequest\n) {\n  let msg: string\n  if (xhr.response) {\n    msg = `${xhr.response.error || xhr.response}`\n  } else if (xhr.responseText) {\n    msg = `${xhr.responseText}`\n  } else {\n    msg = `fail to ${option.method} ${action} ${xhr.status}`\n  }\n\n  return new UploadAjaxError(msg, xhr.status, option.method, action)\n}\n\nfunction getBody(xhr: XMLHttpRequest): XMLHttpRequestResponseType {\n  const text = xhr.responseText || xhr.response\n  if (!text) {\n    return text\n  }\n\n  try {\n    return JSON.parse(text)\n  } catch {\n    return text\n  }\n}\n\nexport const ajaxUpload: UploadRequestHandler = (option) => {\n  if (typeof XMLHttpRequest === 'undefined')\n    throwError(SCOPE, 'XMLHttpRequest is undefined')\n\n  const xhr = new XMLHttpRequest()\n  const action = option.action\n\n  if (xhr.upload) {\n    xhr.upload.addEventListener('progress', (evt) => {\n      const progressEvt = evt as UploadProgressEvent\n      progressEvt.percent = evt.total > 0 ? (evt.loaded / evt.total) * 100 : 0\n      option.onProgress(progressEvt)\n    })\n  }\n\n  const formData = new FormData()\n  if (option.data) {\n    for (const [key, value] of Object.entries(option.data)) {\n      if (Array.isArray(value)) formData.append(key, ...value)\n      else formData.append(key, value)\n    }\n  }\n  formData.append(option.filename, option.file, option.file.name)\n\n  xhr.addEventListener('error', () => {\n    option.onError(getError(action, option, xhr))\n  })\n\n  xhr.addEventListener('load', () => {\n    if (xhr.status < 200 || xhr.status >= 300) {\n      return option.onError(getError(action, option, xhr))\n    }\n    option.onSuccess(getBody(xhr))\n  })\n\n  xhr.open(option.method, action, true)\n\n  if (option.withCredentials && 'withCredentials' in xhr) {\n    xhr.withCredentials = true\n  }\n\n  const headers = option.headers || {}\n  if (headers instanceof Headers) {\n    headers.forEach((value, key) => xhr.setRequestHeader(key, value))\n  } else {\n    for (const [key, value] of Object.entries(headers)) {\n      if (isNil(value)) continue\n      xhr.setRequestHeader(key, String(value))\n    }\n  }\n\n  xhr.send(formData)\n  return xhr\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}