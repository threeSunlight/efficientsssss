{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { defineComponent, ref, computed, watch, onBeforeUnmount, openBlock, createBlock, unref, createSlots, renderList, withCtx, renderSlot } from 'vue';\nimport { ElStatistic } from '../../statistic/index.mjs';\nimport '../../../utils/index.mjs';\nimport { countdownProps, countdownEmits } from './countdown.mjs';\nimport { getTime, formatTime } from './utils.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { cAF, rAF } from '../../../utils/raf.mjs';\nvar __default__ = defineComponent({\n  name: \"ElCountdown\"\n});\nvar _sfc_main = /* @__PURE__ */defineComponent(_objectSpread(_objectSpread({}, __default__), {}, {\n  props: countdownProps,\n  emits: countdownEmits,\n  setup: function setup(__props, _ref) {\n    var expose = _ref.expose,\n      emit = _ref.emit;\n    var props = __props;\n    var timer;\n    var rawValue = ref(getTime(props.value) - Date.now());\n    var displayValue = computed(function () {\n      return formatTime(rawValue.value, props.format);\n    });\n    var formatter = function formatter(val) {\n      return formatTime(val, props.format);\n    };\n    var stopTimer = function stopTimer() {\n      if (timer) {\n        cAF(timer);\n        timer = void 0;\n      }\n    };\n    var startTimer = function startTimer() {\n      var timestamp = getTime(props.value);\n      var frameFunc = function frameFunc() {\n        var diff = timestamp - Date.now();\n        emit(\"change\", diff);\n        if (diff <= 0) {\n          diff = 0;\n          stopTimer();\n          emit(\"finish\");\n        } else {\n          timer = rAF(frameFunc);\n        }\n        rawValue.value = diff;\n      };\n      timer = rAF(frameFunc);\n    };\n    watch(function () {\n      return [props.value, props.format];\n    }, function () {\n      stopTimer();\n      startTimer();\n    }, {\n      immediate: true\n    });\n    onBeforeUnmount(function () {\n      stopTimer();\n    });\n    expose({\n      displayValue: displayValue\n    });\n    return function (_ctx, _cache) {\n      return openBlock(), createBlock(unref(ElStatistic), {\n        value: rawValue.value,\n        title: _ctx.title,\n        prefix: _ctx.prefix,\n        suffix: _ctx.suffix,\n        \"value-style\": _ctx.valueStyle,\n        formatter: formatter\n      }, createSlots({\n        _: 2\n      }, [renderList(_ctx.$slots, function (_, name) {\n        return {\n          name: name,\n          fn: withCtx(function () {\n            return [renderSlot(_ctx.$slots, name)];\n          })\n        };\n      })]), 1032, [\"value\", \"title\", \"prefix\", \"suffix\", \"value-style\"]);\n    };\n  }\n}));\nvar Countdown = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/countdown/src/countdown.vue\"]]);\nexport { Countdown as default };","map":{"version":3,"names":["name","timer","rawValue","ref","getTime","props","value","Date","now","displayValue","computed","formatTime","format","formatter","val","stopTimer","cAF","startTimer","timestamp","frameFunc","diff","emit","rAF","watch","immediate","onBeforeUnmount","expose"],"sources":["../../../../../../packages/components/countdown/src/countdown.vue"],"sourcesContent":["<template>\n  <el-statistic\n    :value=\"rawValue\"\n    :title=\"title\"\n    :prefix=\"prefix\"\n    :suffix=\"suffix\"\n    :value-style=\"valueStyle\"\n    :formatter=\"formatter\"\n  >\n    <template v-for=\"(_, name) in $slots\" #[name]>\n      <slot :name=\"name\" />\n    </template>\n  </el-statistic>\n</template>\n<script lang=\"ts\" setup>\nimport { computed, onBeforeUnmount, ref, watch } from 'vue'\nimport { ElStatistic } from '@element-plus/components/statistic'\nimport { cAF, rAF } from '@element-plus/utils'\nimport { countdownEmits, countdownProps } from './countdown'\nimport { formatTime, getTime } from './utils'\n\ndefineOptions({\n  name: 'ElCountdown',\n})\n\nconst props = defineProps(countdownProps)\nconst emit = defineEmits(countdownEmits)\n\nlet timer: ReturnType<typeof rAF> | undefined\nconst rawValue = ref(getTime(props.value) - Date.now())\nconst displayValue = computed(() => formatTime(rawValue.value, props.format))\n\nconst formatter = (val: number) => formatTime(val, props.format)\n\nconst stopTimer = () => {\n  if (timer) {\n    cAF(timer)\n    timer = undefined\n  }\n}\n\nconst startTimer = () => {\n  const timestamp = getTime(props.value)\n  const frameFunc = () => {\n    let diff = timestamp - Date.now()\n    emit('change', diff)\n    if (diff <= 0) {\n      diff = 0\n      stopTimer()\n      emit('finish')\n    } else {\n      timer = rAF(frameFunc)\n    }\n    rawValue.value = diff\n  }\n  timer = rAF(frameFunc)\n}\n\nwatch(\n  () => [props.value, props.format],\n  () => {\n    stopTimer()\n    startTimer()\n  },\n  {\n    immediate: true,\n  }\n)\n\nonBeforeUnmount(() => {\n  stopTimer()\n})\n\ndefineExpose({\n  /**\n   * @description current display value\n   */\n  displayValue,\n})\n</script>\n"],"mappings":";;;;;;;;;;;;;iCAqBc;EACZA,IAAM;AACR;;;;;;;;IAKI,IAAAC,KAAA;IACE,IAAAC,QAAA,GAAWC,GAAA,CAAIC,OAAQ,CAAAC,KAAA,CAAMC,KAAK,CAAI,GAAAC,IAAA,CAAKC,GAAA,EAAK;IAChD,IAAAC,YAAA,GAAeC,QAAA,CAAS;MAAA,OAAMC,UAAA,CAAWT,QAAA,CAASI,KAAO,EAAAD,KAAA,CAAMO,MAAM,CAAC;IAAA;IAE5E,IAAMC,SAAA,GAAY,SAAZA,UAAaC,GAAA;MAAA,OAAgBH,UAAW,CAAAG,GAAA,EAAKT,KAAA,CAAMO,MAAM;IAAA;IAE/D,IAAMG,SAAA,GAAY,SAAZA,UAAA,EAAkB;MACtB,IAAId,KAAO;QACTe,GAAA,CAAIf,KAAK;QACDA,KAAA;MAAA;IACV,CACF;IAEA,IAAMgB,UAAA,GAAa,SAAbA,WAAA,EAAmB;MACjB,IAAAC,SAAA,GAAYd,OAAQ,CAAAC,KAAA,CAAMC,KAAK;MACrC,IAAMa,SAAA,GAAY,SAAZA,UAAA,EAAkB;QAClB,IAAAC,IAAA,GAAOF,SAAY,GAAAX,IAAA,CAAKC,GAAI;QAChCa,IAAA,CAAK,UAAUD,IAAI;QACnB,IAAIA,IAAA,IAAQ,CAAG;UACNA,IAAA;UACGL,SAAA;UACVM,IAAA,CAAK,QAAQ;QAAA,CACR;UACLpB,KAAA,GAAQqB,GAAA,CAAIH,SAAS;QAAA;QAEvBjB,QAAA,CAASI,KAAQ,GAAAc,IAAA;MAAA,CACnB;MACAnB,KAAA,GAAQqB,GAAA,CAAIH,SAAS;IAAA,CACvB;IAEAI,KAAA,CACE;MAAA,OAAM,CAAClB,KAAA,CAAMC,KAAA,EAAOD,KAAM,CAAAO,MAAM;IAAA,GAChC,YAAM;MACMG,SAAA;MACCE,UAAA;IAAA,CAEb;MACEO,SAAW;IAAA,CAEf;IAEAC,eAAA,CAAgB,YAAM;MACVV,SAAA;IAAA,CACX;IAEYW,MAAA;MAIXjB,YAAA,EAAAA;IAAA,CACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}