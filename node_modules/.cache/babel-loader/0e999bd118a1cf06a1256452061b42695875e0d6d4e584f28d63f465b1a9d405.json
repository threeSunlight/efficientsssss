{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { warn } from 'vue';\nimport { fromPairs } from 'lodash-unified';\nimport '../../types.mjs';\nimport '../../objects.mjs';\nimport { isObject, hasOwn } from '@vue/shared';\nvar epPropKey = \"__epPropKey\";\nvar definePropType = function definePropType(val) {\n  return val;\n};\nvar isEpProp = function isEpProp(val) {\n  return isObject(val) && !!val[epPropKey];\n};\nvar buildProp = function buildProp(prop, key) {\n  if (!isObject(prop) || isEpProp(prop)) return prop;\n  var values = prop.values,\n    required = prop.required,\n    defaultValue = prop[\"default\"],\n    type = prop.type,\n    validator = prop.validator;\n  var _validator = values || validator ? function (val) {\n    var valid = false;\n    var allowedValues = [];\n    if (values) {\n      allowedValues = Array.from(values);\n      if (hasOwn(prop, \"default\")) {\n        allowedValues.push(defaultValue);\n      }\n      valid || (valid = allowedValues.includes(val));\n    }\n    if (validator) valid || (valid = validator(val));\n    if (!valid && allowedValues.length > 0) {\n      var allowValuesText = _toConsumableArray(new Set(allowedValues)).map(function (value) {\n        return JSON.stringify(value);\n      }).join(\", \");\n      warn(\"Invalid prop: validation failed\".concat(key ? \" for prop \\\"\".concat(key, \"\\\"\") : \"\", \". Expected one of [\").concat(allowValuesText, \"], got value \").concat(JSON.stringify(val), \".\"));\n    }\n    return valid;\n  } : void 0;\n  var epProp = _defineProperty({\n    type: type,\n    required: !!required,\n    validator: _validator\n  }, epPropKey, true);\n  if (hasOwn(prop, \"default\")) epProp[\"default\"] = defaultValue;\n  return epProp;\n};\nvar buildProps = function buildProps(props) {\n  return fromPairs(Object.entries(props).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      key = _ref2[0],\n      option = _ref2[1];\n    return [key, buildProp(option, key)];\n  }));\n};\nexport { buildProp, buildProps, definePropType, epPropKey, isEpProp };","map":{"version":3,"names":["epPropKey","definePropType","val","isEpProp","isObject","buildProp","prop","key","values","required","defaultValue","type","validator","_validator","valid","allowedValues","Array","from","hasOwn","push","includes","length","allowValuesText","_toConsumableArray","Set","map","value","JSON","stringify","join","warn","concat","epProp","_defineProperty","buildProps","props","fromPairs","Object","entries","_ref","_ref2","_slicedToArray","option"],"sources":["../../../../../../packages/utils/vue/props/runtime.ts"],"sourcesContent":["import { warn } from 'vue'\nimport { fromPairs } from 'lodash-unified'\nimport { isObject } from '../../types'\nimport { hasOwn } from '../../objects'\n\nimport type { PropType } from 'vue'\nimport type {\n  EpProp,\n  EpPropConvert,\n  EpPropFinalized,\n  EpPropInput,\n  EpPropMergeType,\n  IfEpProp,\n  IfNativePropType,\n  NativePropType,\n} from './types'\n\nexport const epPropKey = '__epPropKey'\n\nexport const definePropType = <T>(val: any): PropType<T> => val\n\nexport const isEpProp = (val: unknown): val is EpProp<any, any, any> =>\n  isObject(val) && !!(val as any)[epPropKey]\n\n/**\n * @description Build prop. It can better optimize prop types\n * @description 生成 prop，能更好地优化类型\n * @example\n  // limited options\n  // the type will be PropType<'light' | 'dark'>\n  buildProp({\n    type: String,\n    values: ['light', 'dark'],\n  } as const)\n  * @example\n  // limited options and other types\n  // the type will be PropType<'small' | 'large' | number>\n  buildProp({\n    type: [String, Number],\n    values: ['small', 'large'],\n    validator: (val: unknown): val is number => typeof val === 'number',\n  } as const)\n  @link see more: https://github.com/element-plus/element-plus/pull/3341\n */\nexport const buildProp = <\n  Type = never,\n  Value = never,\n  Validator = never,\n  Default extends EpPropMergeType<Type, Value, Validator> = never,\n  Required extends boolean = false\n>(\n  prop: EpPropInput<Type, Value, Validator, Default, Required>,\n  key?: string\n): EpPropFinalized<Type, Value, Validator, Default, Required> => {\n  // filter native prop type and nested prop, e.g `null`, `undefined` (from `buildProps`)\n  if (!isObject(prop) || isEpProp(prop)) return prop as any\n\n  const { values, required, default: defaultValue, type, validator } = prop\n\n  const _validator =\n    values || validator\n      ? (val: unknown) => {\n          let valid = false\n          let allowedValues: unknown[] = []\n\n          if (values) {\n            allowedValues = Array.from(values)\n            if (hasOwn(prop, 'default')) {\n              allowedValues.push(defaultValue)\n            }\n            valid ||= allowedValues.includes(val)\n          }\n          if (validator) valid ||= validator(val)\n\n          if (!valid && allowedValues.length > 0) {\n            const allowValuesText = [...new Set(allowedValues)]\n              .map((value) => JSON.stringify(value))\n              .join(', ')\n            warn(\n              `Invalid prop: validation failed${\n                key ? ` for prop \"${key}\"` : ''\n              }. Expected one of [${allowValuesText}], got value ${JSON.stringify(\n                val\n              )}.`\n            )\n          }\n          return valid\n        }\n      : undefined\n\n  const epProp: any = {\n    type,\n    required: !!required,\n    validator: _validator,\n    [epPropKey]: true,\n  }\n  if (hasOwn(prop, 'default')) epProp.default = defaultValue\n  return epProp\n}\n\nexport const buildProps = <\n  Props extends Record<\n    string,\n    | { [epPropKey]: true }\n    | NativePropType\n    | EpPropInput<any, any, any, any, any>\n  >\n>(\n  props: Props\n): {\n  [K in keyof Props]: IfEpProp<\n    Props[K],\n    Props[K],\n    IfNativePropType<Props[K], Props[K], EpPropConvert<Props[K]>>\n  >\n} =>\n  fromPairs(\n    Object.entries(props).map(([key, option]) => [\n      key,\n      buildProp(option as any, key),\n    ])\n  ) as any\n"],"mappings":";;;;;;;;;;;;;;;;;;;AAIY,IAACA,SAAS,GAAG;AACb,IAACC,cAAc,GAAG,SAAjBA,cAAcA,CAAIC,GAAG;EAAA,OAAKA,GAAA;AAAA;AAC3B,IAACC,QAAQ,GAAG,SAAXA,QAAQA,CAAID,GAAG;EAAA,OAAKE,QAAQ,CAACF,GAAG,CAAC,IAAI,CAAC,CAACA,GAAG,CAACF,SAAS;AAAA;AACrD,IAACK,SAAS,GAAG,SAAZA,SAASA,CAAIC,IAAI,EAAEC,GAAG,EAAK;EACtC,IAAI,CAACH,QAAQ,CAACE,IAAI,CAAC,IAAIH,QAAQ,CAACG,IAAI,CAAC,EACnC,OAAOA,IAAI;EACb,IAAQE,MAAM,GAAuDF,IAAI,CAAjEE,MAAM;IAAEC,QAAQ,GAA6CH,IAAI,CAAzDG,QAAQ;IAAWC,YAAY,GAAsBJ,IAAI;IAAxBK,IAAI,GAAgBL,IAAI,CAAxBK,IAAI;IAAEC,SAAS,GAAKN,IAAI,CAAlBM,SAAS;EAChE,IAAMC,UAAU,GAAGL,MAAM,IAAII,SAAS,GAAG,UAACV,GAAG,EAAK;IAChD,IAAIY,KAAK,GAAG,KAAK;IACjB,IAAIC,aAAa,GAAG,EAAE;IACtB,IAAIP,MAAM,EAAE;MACVO,aAAa,GAAGC,KAAK,CAACC,IAAI,CAACT,MAAM,CAAC;MAClC,IAAIU,MAAM,CAACZ,IAAI,EAAE,SAAS,CAAC,EAAE;QAC3BS,aAAa,CAACI,IAAI,CAACT,YAAY,CAAC;MACxC;MACMI,KAAK,KAAKA,KAAK,GAAGC,aAAa,CAACK,QAAQ,CAAClB,GAAG,CAAC,CAAC;IACpD;IACI,IAAIU,SAAS,EACXE,KAAK,KAAKA,KAAK,GAAGF,SAAS,CAACV,GAAG,CAAC,CAAC;IACnC,IAAI,CAACY,KAAK,IAAIC,aAAa,CAACM,MAAM,GAAG,CAAC,EAAE;MACtC,IAAMC,eAAe,GAAGC,kBAAA,CAAI,IAAIC,GAAG,CAACT,aAAa,CAAC,EAAEU,GAAG,CAAC,UAACC,KAAK;QAAA,OAAKC,IAAI,CAACC,SAAS,CAACF,KAAK,CAAC;MAAA,EAAC,CAACG,IAAI,CAAC,IAAI,CAAC;MACpGC,IAAI,mCAAAC,MAAA,CAAmCxB,GAAG,kBAAAwB,MAAA,CAAiBxB,GAAG,UAAM,EAAE,yBAAAwB,MAAA,CAAsBT,eAAe,mBAAAS,MAAA,CAAgBJ,IAAI,CAACC,SAAS,CAAC1B,GAAG,CAAC,MAAG,CAAC;IACxJ;IACI,OAAOY,KAAK;EAChB,CAAG,GAAG,KAAK,CAAC;EACV,IAAMkB,MAAM,GAAAC,eAAA;IACVtB,IAAI,EAAJA,IAAI;IACJF,QAAQ,EAAE,CAAC,CAACA,QAAQ;IACpBG,SAAS,EAAEC;EAAU,GACpBb,SAAS,EAAG,IAAI,CAClB;EACD,IAAIkB,MAAM,CAACZ,IAAI,EAAE,SAAS,CAAC,EACzB0B,MAAM,WAAQ,GAAGtB,YAAY;EAC/B,OAAOsB,MAAM;AACf;AACY,IAACE,UAAU,GAAG,SAAbA,UAAUA,CAAIC,KAAK;EAAA,OAAKC,SAAS,CAACC,MAAM,CAACC,OAAO,CAACH,KAAK,CAAC,CAACV,GAAG,CAAC,UAAAc,IAAA;IAAA,IAAAC,KAAA,GAAAC,cAAA,CAAAF,IAAA;MAAEhC,GAAG,GAAAiC,KAAA;MAAEE,MAAM,GAAAF,KAAA;IAAA,OAAM,CAC1FjC,GAAG,EACHF,SAAS,CAACqC,MAAM,EAAEnC,GAAG,CAAC,CACvB;EAAA,EAAC;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}