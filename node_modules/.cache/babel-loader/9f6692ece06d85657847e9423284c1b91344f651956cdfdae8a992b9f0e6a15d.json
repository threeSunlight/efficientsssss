{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { ref, getCurrentInstance, watch, nextTick } from 'vue';\nimport { SetOperationEnum, NODE_CHECK, NODE_CHECK_CHANGE } from '../virtual-tree.mjs';\nfunction useCheck(props, tree) {\n  var checkedKeys = ref( /* @__PURE__ */new Set());\n  var indeterminateKeys = ref( /* @__PURE__ */new Set());\n  var _getCurrentInstance = getCurrentInstance(),\n    emit = _getCurrentInstance.emit;\n  watch([function () {\n    return tree.value;\n  }, function () {\n    return props.defaultCheckedKeys;\n  }], function () {\n    return nextTick(function () {\n      _setCheckedKeys(props.defaultCheckedKeys);\n    });\n  }, {\n    immediate: true\n  });\n  var updateCheckedKeys = function updateCheckedKeys() {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return;\n    }\n    var _tree$value = tree.value,\n      levelTreeNodeMap = _tree$value.levelTreeNodeMap,\n      maxLevel = _tree$value.maxLevel;\n    var checkedKeySet = checkedKeys.value;\n    var indeterminateKeySet = /* @__PURE__ */new Set();\n    for (var level = maxLevel - 1; level >= 1; --level) {\n      var nodes = levelTreeNodeMap.get(level);\n      if (!nodes) continue;\n      nodes.forEach(function (node) {\n        var children = node.children;\n        if (children) {\n          var allChecked = true;\n          var hasChecked = false;\n          var _iterator = _createForOfIteratorHelper(children),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var childNode = _step.value;\n              var key = childNode.key;\n              if (checkedKeySet.has(key)) {\n                hasChecked = true;\n              } else if (indeterminateKeySet.has(key)) {\n                allChecked = false;\n                hasChecked = true;\n                break;\n              } else {\n                allChecked = false;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n          if (allChecked) {\n            checkedKeySet.add(node.key);\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key);\n            checkedKeySet[\"delete\"](node.key);\n          } else {\n            checkedKeySet[\"delete\"](node.key);\n            indeterminateKeySet[\"delete\"](node.key);\n          }\n        }\n      });\n    }\n    indeterminateKeys.value = indeterminateKeySet;\n  };\n  var isChecked = function isChecked(node) {\n    return checkedKeys.value.has(node.key);\n  };\n  var isIndeterminate = function isIndeterminate(node) {\n    return indeterminateKeys.value.has(node.key);\n  };\n  var toggleCheckbox = function toggleCheckbox(node, isChecked2) {\n    var nodeClick = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    var checkedKeySet = checkedKeys.value;\n    var toggle = function toggle(node2, checked) {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);\n      var children = node2.children;\n      if (!props.checkStrictly && children) {\n        children.forEach(function (childNode) {\n          if (!childNode.disabled) {\n            toggle(childNode, checked);\n          }\n        });\n      }\n    };\n    toggle(node, isChecked2);\n    updateCheckedKeys();\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked2);\n    }\n  };\n  var afterNodeCheck = function afterNodeCheck(node, checked) {\n    var _getChecked = getChecked(),\n      checkedNodes = _getChecked.checkedNodes,\n      checkedKeys2 = _getChecked.checkedKeys;\n    var _getHalfChecked = getHalfChecked(),\n      halfCheckedNodes = _getHalfChecked.halfCheckedNodes,\n      halfCheckedKeys = _getHalfChecked.halfCheckedKeys;\n    emit(NODE_CHECK, node.data, {\n      checkedKeys: checkedKeys2,\n      checkedNodes: checkedNodes,\n      halfCheckedKeys: halfCheckedKeys,\n      halfCheckedNodes: halfCheckedNodes\n    });\n    emit(NODE_CHECK_CHANGE, node.data, checked);\n  };\n  function getCheckedKeys() {\n    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return getChecked(leafOnly).checkedKeys;\n  }\n  function getCheckedNodes() {\n    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return getChecked(leafOnly).checkedNodes;\n  }\n  function getHalfCheckedKeys() {\n    return getHalfChecked().halfCheckedKeys;\n  }\n  function getHalfCheckedNodes() {\n    return getHalfChecked().halfCheckedNodes;\n  }\n  function getChecked() {\n    var leafOnly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var checkedNodes = [];\n    var keys = [];\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      var treeNodeMap = tree.value.treeNodeMap;\n      checkedKeys.value.forEach(function (key) {\n        var node = treeNodeMap.get(key);\n        if (node && (!leafOnly || leafOnly && node.isLeaf)) {\n          keys.push(key);\n          checkedNodes.push(node.data);\n        }\n      });\n    }\n    return {\n      checkedKeys: keys,\n      checkedNodes: checkedNodes\n    };\n  }\n  function getHalfChecked() {\n    var halfCheckedNodes = [];\n    var halfCheckedKeys = [];\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      var treeNodeMap = tree.value.treeNodeMap;\n      indeterminateKeys.value.forEach(function (key) {\n        var node = treeNodeMap.get(key);\n        if (node) {\n          halfCheckedKeys.push(key);\n          halfCheckedNodes.push(node.data);\n        }\n      });\n    }\n    return {\n      halfCheckedNodes: halfCheckedNodes,\n      halfCheckedKeys: halfCheckedKeys\n    };\n  }\n  function setCheckedKeys(keys) {\n    checkedKeys.value.clear();\n    indeterminateKeys.value.clear();\n    _setCheckedKeys(keys);\n  }\n  function setChecked(key, isChecked2) {\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      var node = tree.value.treeNodeMap.get(key);\n      if (node) {\n        toggleCheckbox(node, isChecked2, false);\n      }\n    }\n  }\n  function _setCheckedKeys(keys) {\n    if (tree == null ? void 0 : tree.value) {\n      var treeNodeMap = tree.value.treeNodeMap;\n      if (props.showCheckbox && treeNodeMap && keys) {\n        var _iterator2 = _createForOfIteratorHelper(keys),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var key = _step2.value;\n            var node = treeNodeMap.get(key);\n            if (node && !isChecked(node)) {\n              toggleCheckbox(node, true, false);\n            }\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n    }\n  }\n  return {\n    updateCheckedKeys: updateCheckedKeys,\n    toggleCheckbox: toggleCheckbox,\n    isChecked: isChecked,\n    isIndeterminate: isIndeterminate,\n    getCheckedKeys: getCheckedKeys,\n    getCheckedNodes: getCheckedNodes,\n    getHalfCheckedKeys: getHalfCheckedKeys,\n    getHalfCheckedNodes: getHalfCheckedNodes,\n    setChecked: setChecked,\n    setCheckedKeys: setCheckedKeys\n  };\n}\nexport { useCheck };","map":{"version":3,"names":["useCheck","props","tree","checkedKeys","ref","Set","indeterminateKeys","_getCurrentInstance","getCurrentInstance","emit","watch","value","defaultCheckedKeys","nextTick","_setCheckedKeys","immediate","updateCheckedKeys","showCheckbox","checkStrictly","_tree$value","levelTreeNodeMap","maxLevel","checkedKeySet","indeterminateKeySet","level","nodes","get","forEach","node","children","allChecked","hasChecked","_iterator","_createForOfIteratorHelper","_step","s","n","done","childNode","key","has","err","e","f","add","isChecked","isIndeterminate","toggleCheckbox","isChecked2","nodeClick","arguments","length","undefined","toggle","node2","checked","SetOperationEnum","ADD","DELETE","disabled","afterNodeCheck","_getChecked","getChecked","checkedNodes","checkedKeys2","_getHalfChecked","getHalfChecked","halfCheckedNodes","halfCheckedKeys","NODE_CHECK","data","NODE_CHECK_CHANGE","getCheckedKeys","leafOnly","getCheckedNodes","getHalfCheckedKeys","getHalfCheckedNodes","keys","treeNodeMap","isLeaf","push","setCheckedKeys","clear","setChecked","_iterator2","_step2"],"sources":["../../../../../../../packages/components/tree-v2/src/composables/useCheck.ts"],"sourcesContent":["import { getCurrentInstance, nextTick, ref, watch } from 'vue'\nimport {\n  NODE_CHECK,\n  NODE_CHECK_CHANGE,\n  SetOperationEnum,\n} from '../virtual-tree'\nimport type { CheckboxValueType } from '@element-plus/components/checkbox'\nimport type { Ref } from 'vue'\nimport type { Tree, TreeKey, TreeNode, TreeNodeData, TreeProps } from '../types'\n\nexport function useCheck(props: TreeProps, tree: Ref<Tree | undefined>) {\n  const checkedKeys = ref<Set<TreeKey>>(new Set())\n  const indeterminateKeys = ref<Set<TreeKey>>(new Set())\n  const { emit } = getCurrentInstance()!\n\n  watch(\n    [() => tree.value, () => props.defaultCheckedKeys],\n    () => {\n      return nextTick(() => {\n        _setCheckedKeys(props.defaultCheckedKeys)\n      })\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  const updateCheckedKeys = () => {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return\n    }\n    const { levelTreeNodeMap, maxLevel } = tree.value\n    const checkedKeySet = checkedKeys.value\n    const indeterminateKeySet = new Set<TreeKey>()\n    // It is easier to determine the indeterminate state by\n    // traversing from bottom to top\n    // leaf nodes not have indeterminate status and can be skipped\n    for (let level = maxLevel - 1; level >= 1; --level) {\n      const nodes = levelTreeNodeMap.get(level)\n      if (!nodes) continue\n      nodes.forEach((node) => {\n        const children = node.children\n        if (children) {\n          // Whether all child nodes are selected\n          let allChecked = true\n          // Whether a child node is selected\n          let hasChecked = false\n          for (const childNode of children) {\n            const key = childNode.key\n            if (checkedKeySet.has(key)) {\n              hasChecked = true\n            } else if (indeterminateKeySet.has(key)) {\n              allChecked = false\n              hasChecked = true\n              break\n            } else {\n              allChecked = false\n            }\n          }\n          if (allChecked) {\n            checkedKeySet.add(node.key)\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key)\n            checkedKeySet.delete(node.key)\n          } else {\n            checkedKeySet.delete(node.key)\n            indeterminateKeySet.delete(node.key)\n          }\n        }\n      })\n    }\n    indeterminateKeys.value = indeterminateKeySet\n  }\n\n  const isChecked = (node: TreeNode) => checkedKeys.value.has(node.key)\n\n  const isIndeterminate = (node: TreeNode) =>\n    indeterminateKeys.value.has(node.key)\n\n  const toggleCheckbox = (\n    node: TreeNode,\n    isChecked: CheckboxValueType,\n    nodeClick = true\n  ) => {\n    const checkedKeySet = checkedKeys.value\n    const toggle = (node: TreeNode, checked: CheckboxValueType) => {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](\n        node.key\n      )\n      const children = node.children\n      if (!props.checkStrictly && children) {\n        children.forEach((childNode) => {\n          if (!childNode.disabled) {\n            toggle(childNode, checked)\n          }\n        })\n      }\n    }\n    toggle(node, isChecked)\n    updateCheckedKeys()\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked)\n    }\n  }\n\n  const afterNodeCheck = (node: TreeNode, checked: CheckboxValueType) => {\n    const { checkedNodes, checkedKeys } = getChecked()\n    const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked()\n    emit(NODE_CHECK, node.data, {\n      checkedKeys,\n      checkedNodes,\n      halfCheckedKeys,\n      halfCheckedNodes,\n    })\n    emit(NODE_CHECK_CHANGE, node.data, checked)\n  }\n\n  // expose\n  function getCheckedKeys(leafOnly = false): TreeKey[] {\n    return getChecked(leafOnly).checkedKeys\n  }\n\n  function getCheckedNodes(leafOnly = false): TreeNodeData[] {\n    return getChecked(leafOnly).checkedNodes\n  }\n\n  function getHalfCheckedKeys(): TreeKey[] {\n    return getHalfChecked().halfCheckedKeys\n  }\n\n  function getHalfCheckedNodes(): TreeNodeData[] {\n    return getHalfChecked().halfCheckedNodes\n  }\n\n  function getChecked(leafOnly = false): {\n    checkedKeys: TreeKey[]\n    checkedNodes: TreeNodeData[]\n  } {\n    const checkedNodes: TreeNodeData[] = []\n    const keys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      checkedKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node && (!leafOnly || (leafOnly && node.isLeaf))) {\n          keys.push(key)\n          checkedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      checkedKeys: keys,\n      checkedNodes,\n    }\n  }\n\n  function getHalfChecked(): {\n    halfCheckedKeys: TreeKey[]\n    halfCheckedNodes: TreeNodeData[]\n  } {\n    const halfCheckedNodes: TreeNodeData[] = []\n    const halfCheckedKeys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      indeterminateKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node) {\n          halfCheckedKeys.push(key)\n          halfCheckedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      halfCheckedNodes,\n      halfCheckedKeys,\n    }\n  }\n\n  function setCheckedKeys(keys: TreeKey[]) {\n    checkedKeys.value.clear()\n    indeterminateKeys.value.clear()\n    _setCheckedKeys(keys)\n  }\n\n  function setChecked(key: TreeKey, isChecked: boolean) {\n    if (tree?.value && props.showCheckbox) {\n      const node = tree.value.treeNodeMap.get(key)\n      if (node) {\n        toggleCheckbox(node, isChecked, false)\n      }\n    }\n  }\n\n  function _setCheckedKeys(keys: TreeKey[]) {\n    if (tree?.value) {\n      const { treeNodeMap } = tree.value\n      if (props.showCheckbox && treeNodeMap && keys) {\n        for (const key of keys) {\n          const node = treeNodeMap.get(key)\n          if (node && !isChecked(node)) {\n            toggleCheckbox(node, true, false)\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    updateCheckedKeys,\n    toggleCheckbox,\n    isChecked,\n    isIndeterminate,\n    // expose\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}