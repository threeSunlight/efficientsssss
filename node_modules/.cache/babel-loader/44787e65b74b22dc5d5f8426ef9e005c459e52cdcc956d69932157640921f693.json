{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport { ref, onMounted, onBeforeUnmount } from 'vue';\nimport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS } from './tokens.mjs';\nvar focusReason = ref();\nvar lastUserFocusTimestamp = ref(0);\nvar lastAutomatedFocusTimestamp = ref(0);\nvar focusReasonUserCount = 0;\nvar obtainAllFocusableElements = function obtainAllFocusableElements(element) {\n  var nodes = [];\n  var walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: function acceptNode(node) {\n      var isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 || node === document.activeElement ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n  return nodes;\n};\nvar getVisibleElement = function getVisibleElement(elements, container) {\n  var _iterator = _createForOfIteratorHelper(elements),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var element = _step.value;\n      if (!isHidden(element, container)) return element;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n};\nvar isHidden = function isHidden(element, container) {\n  if (process.env.NODE_ENV === \"test\") return false;\n  if (getComputedStyle(element).visibility === \"hidden\") return true;\n  while (element) {\n    if (container && element === container) return false;\n    if (getComputedStyle(element).display === \"none\") return true;\n    element = element.parentElement;\n  }\n  return false;\n};\nvar getEdges = function getEdges(container) {\n  var focusable = obtainAllFocusableElements(container);\n  var first = getVisibleElement(focusable, container);\n  var last = getVisibleElement(focusable.reverse(), container);\n  return [first, last];\n};\nvar isSelectable = function isSelectable(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n};\nvar tryFocus = function tryFocus(element, shouldSelect) {\n  if (element && element.focus) {\n    var prevFocusedElement = document.activeElement;\n    element.focus({\n      preventScroll: true\n    });\n    lastAutomatedFocusTimestamp.value = window.performance.now();\n    if (element !== prevFocusedElement && isSelectable(element) && shouldSelect) {\n      element.select();\n    }\n  }\n};\nfunction removeFromStack(list, item) {\n  var copy = _toConsumableArray(list);\n  var idx = list.indexOf(item);\n  if (idx !== -1) {\n    copy.splice(idx, 1);\n  }\n  return copy;\n}\nvar createFocusableStack = function createFocusableStack() {\n  var stack = [];\n  var push = function push(layer) {\n    var currentLayer = stack[0];\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause();\n    }\n    stack = removeFromStack(stack, layer);\n    stack.unshift(layer);\n  };\n  var remove = function remove(layer) {\n    var _a, _b;\n    stack = removeFromStack(stack, layer);\n    (_b = (_a = stack[0]) == null ? void 0 : _a.resume) == null ? void 0 : _b.call(_a);\n  };\n  return {\n    push: push,\n    remove: remove\n  };\n};\nvar focusFirstDescendant = function focusFirstDescendant(elements) {\n  var shouldSelect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var prevFocusedElement = document.activeElement;\n  var _iterator2 = _createForOfIteratorHelper(elements),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var element = _step2.value;\n      tryFocus(element, shouldSelect);\n      if (document.activeElement !== prevFocusedElement) return;\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n};\nvar focusableStack = createFocusableStack();\nvar isFocusCausedByUserEvent = function isFocusCausedByUserEvent() {\n  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value;\n};\nvar notifyFocusReasonPointer = function notifyFocusReasonPointer() {\n  focusReason.value = \"pointer\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nvar notifyFocusReasonKeydown = function notifyFocusReasonKeydown() {\n  focusReason.value = \"keyboard\";\n  lastUserFocusTimestamp.value = window.performance.now();\n};\nvar useFocusReason = function useFocusReason() {\n  onMounted(function () {\n    if (focusReasonUserCount === 0) {\n      document.addEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.addEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.addEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n    focusReasonUserCount++;\n  });\n  onBeforeUnmount(function () {\n    focusReasonUserCount--;\n    if (focusReasonUserCount <= 0) {\n      document.removeEventListener(\"mousedown\", notifyFocusReasonPointer);\n      document.removeEventListener(\"touchstart\", notifyFocusReasonPointer);\n      document.removeEventListener(\"keydown\", notifyFocusReasonKeydown);\n    }\n  });\n  return {\n    focusReason: focusReason,\n    lastUserFocusTimestamp: lastUserFocusTimestamp,\n    lastAutomatedFocusTimestamp: lastAutomatedFocusTimestamp\n  };\n};\nvar createFocusOutPreventedEvent = function createFocusOutPreventedEvent(detail) {\n  return new CustomEvent(FOCUSOUT_PREVENTED, _objectSpread(_objectSpread({}, FOCUSOUT_PREVENTED_OPTS), {}, {\n    detail: detail\n  }));\n};\nexport { createFocusOutPreventedEvent, focusFirstDescendant, focusableStack, getEdges, getVisibleElement, isFocusCausedByUserEvent, isHidden, obtainAllFocusableElements, tryFocus, useFocusReason };","map":{"version":3,"names":["focusReason","ref","lastUserFocusTimestamp","lastAutomatedFocusTimestamp","focusReasonUserCount","obtainAllFocusableElements","element","nodes","walker","document","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","tabIndex","activeElement","FILTER_ACCEPT","nextNode","push","currentNode","getVisibleElement","elements","container","_iterator","_createForOfIteratorHelper","_step","s","n","done","value","isHidden","err","e","f","process","env","NODE_ENV","getComputedStyle","visibility","display","parentElement","getEdges","focusable","first","last","reverse","isSelectable","HTMLInputElement","tryFocus","shouldSelect","focus","prevFocusedElement","preventScroll","window","performance","now","select","removeFromStack","list","item","copy","_toConsumableArray","idx","indexOf","splice","createFocusableStack","stack","layer","currentLayer","pause","unshift","remove","_a","_b","resume","call","focusFirstDescendant","arguments","length","undefined","_iterator2","_step2","focusableStack","isFocusCausedByUserEvent","notifyFocusReasonPointer","notifyFocusReasonKeydown","useFocusReason","onMounted","addEventListener","onBeforeUnmount","removeEventListener","createFocusOutPreventedEvent","detail","CustomEvent","FOCUSOUT_PREVENTED","_objectSpread","FOCUSOUT_PREVENTED_OPTS"],"sources":["../../../../../../packages/components/focus-trap/src/utils.ts"],"sourcesContent":["import { onBeforeUnmount, onMounted, ref } from 'vue'\nimport { FOCUSOUT_PREVENTED, FOCUSOUT_PREVENTED_OPTS } from './tokens'\n\nconst focusReason = ref<'pointer' | 'keyboard'>()\nconst lastUserFocusTimestamp = ref<number>(0)\nconst lastAutomatedFocusTimestamp = ref<number>(0)\nlet focusReasonUserCount = 0\n\nexport type FocusLayer = {\n  paused: boolean\n  pause: () => void\n  resume: () => void\n}\n\nexport type FocusStack = FocusLayer[]\n\nexport const obtainAllFocusableElements = (\n  element: HTMLElement\n): HTMLElement[] => {\n  const nodes: HTMLElement[] = []\n  const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (\n      node: Element & {\n        disabled: boolean\n        hidden: boolean\n        type: string\n        tabIndex: number\n      }\n    ) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden'\n      if (node.disabled || node.hidden || isHiddenInput)\n        return NodeFilter.FILTER_SKIP\n      return node.tabIndex >= 0 || node === document.activeElement\n        ? NodeFilter.FILTER_ACCEPT\n        : NodeFilter.FILTER_SKIP\n    },\n  })\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement)\n\n  return nodes\n}\n\nexport const getVisibleElement = (\n  elements: HTMLElement[],\n  container: HTMLElement\n) => {\n  for (const element of elements) {\n    if (!isHidden(element, container)) return element\n  }\n}\n\nexport const isHidden = (element: HTMLElement, container: HTMLElement) => {\n  if (process.env.NODE_ENV === 'test') return false\n  if (getComputedStyle(element).visibility === 'hidden') return true\n\n  while (element) {\n    if (container && element === container) return false\n    if (getComputedStyle(element).display === 'none') return true\n    element = element.parentElement as HTMLElement\n  }\n\n  return false\n}\n\nexport const getEdges = (container: HTMLElement) => {\n  const focusable = obtainAllFocusableElements(container)\n  const first = getVisibleElement(focusable, container)\n  const last = getVisibleElement(focusable.reverse(), container)\n  return [first, last]\n}\n\nconst isSelectable = (\n  element: any\n): element is HTMLInputElement & { select: () => void } => {\n  return element instanceof HTMLInputElement && 'select' in element\n}\n\nexport const tryFocus = (\n  element?: HTMLElement | { focus: () => void } | null,\n  shouldSelect?: boolean\n) => {\n  if (element && element.focus) {\n    const prevFocusedElement = document.activeElement\n    element.focus({ preventScroll: true })\n    lastAutomatedFocusTimestamp.value = window.performance.now()\n    if (\n      element !== prevFocusedElement &&\n      isSelectable(element) &&\n      shouldSelect\n    ) {\n      element.select()\n    }\n  }\n}\n\nfunction removeFromStack<T>(list: T[], item: T) {\n  const copy = [...list]\n\n  const idx = list.indexOf(item)\n\n  if (idx !== -1) {\n    copy.splice(idx, 1)\n  }\n  return copy\n}\n\nconst createFocusableStack = () => {\n  let stack = [] as FocusStack\n\n  const push = (layer: FocusLayer) => {\n    const currentLayer = stack[0]\n\n    if (currentLayer && layer !== currentLayer) {\n      currentLayer.pause()\n    }\n\n    stack = removeFromStack(stack, layer)\n    stack.unshift(layer)\n  }\n\n  const remove = (layer: FocusLayer) => {\n    stack = removeFromStack(stack, layer)\n    stack[0]?.resume?.()\n  }\n\n  return {\n    push,\n    remove,\n  }\n}\n\nexport const focusFirstDescendant = (\n  elements: HTMLElement[],\n  shouldSelect = false\n) => {\n  const prevFocusedElement = document.activeElement\n  for (const element of elements) {\n    tryFocus(element, shouldSelect)\n    if (document.activeElement !== prevFocusedElement) return\n  }\n}\n\nexport const focusableStack = createFocusableStack()\n\nexport const isFocusCausedByUserEvent = (): boolean => {\n  return lastUserFocusTimestamp.value > lastAutomatedFocusTimestamp.value\n}\n\nconst notifyFocusReasonPointer = () => {\n  focusReason.value = 'pointer'\n  lastUserFocusTimestamp.value = window.performance.now()\n}\n\nconst notifyFocusReasonKeydown = () => {\n  focusReason.value = 'keyboard'\n  lastUserFocusTimestamp.value = window.performance.now()\n}\n\nexport const useFocusReason = (): {\n  focusReason: typeof focusReason\n  lastUserFocusTimestamp: typeof lastUserFocusTimestamp\n  lastAutomatedFocusTimestamp: typeof lastAutomatedFocusTimestamp\n} => {\n  onMounted(() => {\n    if (focusReasonUserCount === 0) {\n      document.addEventListener('mousedown', notifyFocusReasonPointer)\n      document.addEventListener('touchstart', notifyFocusReasonPointer)\n      document.addEventListener('keydown', notifyFocusReasonKeydown)\n    }\n    focusReasonUserCount++\n  })\n\n  onBeforeUnmount(() => {\n    focusReasonUserCount--\n    if (focusReasonUserCount <= 0) {\n      document.removeEventListener('mousedown', notifyFocusReasonPointer)\n      document.removeEventListener('touchstart', notifyFocusReasonPointer)\n      document.removeEventListener('keydown', notifyFocusReasonKeydown)\n    }\n  })\n\n  return {\n    focusReason,\n    lastUserFocusTimestamp,\n    lastAutomatedFocusTimestamp,\n  }\n}\n\nexport const createFocusOutPreventedEvent = (\n  detail: CustomEventInit['detail']\n) => {\n  return new CustomEvent(FOCUSOUT_PREVENTED, {\n    ...FOCUSOUT_PREVENTED_OPTS,\n    detail,\n  })\n}\n"],"mappings":";;;;;;;;;;;;;;;AAEA,IAAMA,WAAW,GAAGC,GAAG,EAAE;AACzB,IAAMC,sBAAsB,GAAGD,GAAG,CAAC,CAAC,CAAC;AACrC,IAAME,2BAA2B,GAAGF,GAAG,CAAC,CAAC,CAAC;AAC1C,IAAIG,oBAAoB,GAAG,CAAC;AAChB,IAACC,0BAA0B,GAAG,SAA7BA,0BAA0BA,CAAIC,OAAO,EAAK;EACrD,IAAMC,KAAK,GAAG,EAAE;EAChB,IAAMC,MAAM,GAAGC,QAAQ,CAACC,gBAAgB,CAACJ,OAAO,EAAEK,UAAU,CAACC,YAAY,EAAE;IACzEC,UAAU,EAAE,SAAAA,WAACC,IAAI,EAAK;MACpB,IAAMC,aAAa,GAAGD,IAAI,CAACE,OAAO,KAAK,OAAO,IAAIF,IAAI,CAACG,IAAI,KAAK,QAAQ;MACxE,IAAIH,IAAI,CAACI,QAAQ,IAAIJ,IAAI,CAACK,MAAM,IAAIJ,aAAa,EAC/C,OAAOJ,UAAU,CAACS,WAAW;MAC/B,OAAON,IAAI,CAACO,QAAQ,IAAI,CAAC,IAAIP,IAAI,KAAKL,QAAQ,CAACa,aAAa,GAAGX,UAAU,CAACY,aAAa,GAAGZ,UAAU,CAACS,WAAW;IACtH;EACA,CAAG,CAAC;EACF,OAAOZ,MAAM,CAACgB,QAAQ,EAAE,EACtBjB,KAAK,CAACkB,IAAI,CAACjB,MAAM,CAACkB,WAAW,CAAC;EAChC,OAAOnB,KAAK;AACd;AACY,IAACoB,iBAAiB,GAAG,SAApBA,iBAAiBA,CAAIC,QAAQ,EAAEC,SAAS,EAAK;EAAA,IAAAC,SAAA,GAAAC,0BAAA,CAClCH,QAAQ;IAAAI,KAAA;EAAA;IAA9B,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAAgC;MAAA,IAArB7B,OAAO,GAAA0B,KAAA,CAAAI,KAAA;MAChB,IAAI,CAACC,QAAQ,CAAC/B,OAAO,EAAEuB,SAAS,CAAC,EAC/B,OAAOvB,OAAO;IACpB;EAAG,SAAAgC,GAAA;IAAAR,SAAA,CAAAS,CAAA,CAAAD,GAAA;EAAA;IAAAR,SAAA,CAAAU,CAAA;EAAA;AACH;AACY,IAACH,QAAQ,GAAG,SAAXA,QAAQA,CAAI/B,OAAO,EAAEuB,SAAS,EAAK;EAC9C,IAAIY,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,MAAM,EACjC,OAAO,KAAK;EACd,IAAIC,gBAAgB,CAACtC,OAAO,CAAC,CAACuC,UAAU,KAAK,QAAQ,EACnD,OAAO,IAAI;EACb,OAAOvC,OAAO,EAAE;IACd,IAAIuB,SAAS,IAAIvB,OAAO,KAAKuB,SAAS,EACpC,OAAO,KAAK;IACd,IAAIe,gBAAgB,CAACtC,OAAO,CAAC,CAACwC,OAAO,KAAK,MAAM,EAC9C,OAAO,IAAI;IACbxC,OAAO,GAAGA,OAAO,CAACyC,aAAa;EACnC;EACE,OAAO,KAAK;AACd;AACY,IAACC,QAAQ,GAAG,SAAXA,QAAQA,CAAInB,SAAS,EAAK;EACrC,IAAMoB,SAAS,GAAG5C,0BAA0B,CAACwB,SAAS,CAAC;EACvD,IAAMqB,KAAK,GAAGvB,iBAAiB,CAACsB,SAAS,EAAEpB,SAAS,CAAC;EACrD,IAAMsB,IAAI,GAAGxB,iBAAiB,CAACsB,SAAS,CAACG,OAAO,EAAE,EAAEvB,SAAS,CAAC;EAC9D,OAAO,CAACqB,KAAK,EAAEC,IAAI,CAAC;AACtB;AACA,IAAME,YAAY,GAAG,SAAfA,YAAYA,CAAI/C,OAAO,EAAK;EAChC,OAAOA,OAAO,YAAYgD,gBAAgB,IAAI,QAAQ,IAAIhD,OAAO;AACnE,CAAC;AACW,IAACiD,QAAQ,GAAG,SAAXA,QAAQA,CAAIjD,OAAO,EAAEkD,YAAY,EAAK;EACjD,IAAIlD,OAAO,IAAIA,OAAO,CAACmD,KAAK,EAAE;IAC5B,IAAMC,kBAAkB,GAAGjD,QAAQ,CAACa,aAAa;IACjDhB,OAAO,CAACmD,KAAK,CAAC;MAAEE,aAAa,EAAE;IAAI,CAAE,CAAC;IACtCxD,2BAA2B,CAACiC,KAAK,GAAGwB,MAAM,CAACC,WAAW,CAACC,GAAG,EAAE;IAC5D,IAAIxD,OAAO,KAAKoD,kBAAkB,IAAIL,YAAY,CAAC/C,OAAO,CAAC,IAAIkD,YAAY,EAAE;MAC3ElD,OAAO,CAACyD,MAAM,EAAE;IACtB;EACA;AACA;AACA,SAASC,eAAeA,CAACC,IAAI,EAAEC,IAAI,EAAE;EACnC,IAAMC,IAAI,GAAAC,kBAAA,CAAOH,IAAI,CAAC;EACtB,IAAMI,GAAG,GAAGJ,IAAI,CAACK,OAAO,CAACJ,IAAI,CAAC;EAC9B,IAAIG,GAAG,KAAK,CAAC,CAAC,EAAE;IACdF,IAAI,CAACI,MAAM,CAACF,GAAG,EAAE,CAAC,CAAC;EACvB;EACE,OAAOF,IAAI;AACb;AACA,IAAMK,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAA,EAAS;EACjC,IAAIC,KAAK,GAAG,EAAE;EACd,IAAMhD,IAAI,GAAG,SAAPA,IAAIA,CAAIiD,KAAK,EAAK;IACtB,IAAMC,YAAY,GAAGF,KAAK,CAAC,CAAC,CAAC;IAC7B,IAAIE,YAAY,IAAID,KAAK,KAAKC,YAAY,EAAE;MAC1CA,YAAY,CAACC,KAAK,EAAE;IAC1B;IACIH,KAAK,GAAGT,eAAe,CAACS,KAAK,EAAEC,KAAK,CAAC;IACrCD,KAAK,CAACI,OAAO,CAACH,KAAK,CAAC;EACxB,CAAG;EACD,IAAMI,MAAM,GAAG,SAATA,MAAMA,CAAIJ,KAAK,EAAK;IACxB,IAAIK,EAAE,EAAEC,EAAE;IACVP,KAAK,GAAGT,eAAe,CAACS,KAAK,EAAEC,KAAK,CAAC;IACrC,CAACM,EAAE,GAAG,CAACD,EAAE,GAAGN,KAAK,CAAC,CAAC,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGM,EAAE,CAACE,MAAM,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGD,EAAE,CAACE,IAAI,CAACH,EAAE,CAAC;EACtF,CAAG;EACD,OAAO;IACLtD,IAAI,EAAJA,IAAI;IACJqD,MAAM,EAANA;EACJ,CAAG;AACH,CAAC;AACW,IAACK,oBAAoB,GAAG,SAAvBA,oBAAoBA,CAAIvD,QAAQ,EAA2B;EAAA,IAAzB4B,YAAY,GAAA4B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EACjE,IAAM1B,kBAAkB,GAAGjD,QAAQ,CAACa,aAAa;EAAC,IAAAiE,UAAA,GAAAxD,0BAAA,CAC5BH,QAAQ;IAAA4D,MAAA;EAAA;IAA9B,KAAAD,UAAA,CAAAtD,CAAA,MAAAuD,MAAA,GAAAD,UAAA,CAAArD,CAAA,IAAAC,IAAA,GAAgC;MAAA,IAArB7B,OAAO,GAAAkF,MAAA,CAAApD,KAAA;MAChBmB,QAAQ,CAACjD,OAAO,EAAEkD,YAAY,CAAC;MAC/B,IAAI/C,QAAQ,CAACa,aAAa,KAAKoC,kBAAkB,EAC/C;IACN;EAAG,SAAApB,GAAA;IAAAiD,UAAA,CAAAhD,CAAA,CAAAD,GAAA;EAAA;IAAAiD,UAAA,CAAA/C,CAAA;EAAA;AACH;AACY,IAACiD,cAAc,GAAGjB,oBAAoB;AACtC,IAACkB,wBAAwB,GAAG,SAA3BA,wBAAwBA,CAAA,EAAS;EAC5C,OAAOxF,sBAAsB,CAACkC,KAAK,GAAGjC,2BAA2B,CAACiC,KAAK;AACzE;AACA,IAAMuD,wBAAwB,GAAG,SAA3BA,wBAAwBA,CAAA,EAAS;EACrC3F,WAAW,CAACoC,KAAK,GAAG,SAAS;EAC7BlC,sBAAsB,CAACkC,KAAK,GAAGwB,MAAM,CAACC,WAAW,CAACC,GAAG,EAAE;AACzD,CAAC;AACD,IAAM8B,wBAAwB,GAAG,SAA3BA,wBAAwBA,CAAA,EAAS;EACrC5F,WAAW,CAACoC,KAAK,GAAG,UAAU;EAC9BlC,sBAAsB,CAACkC,KAAK,GAAGwB,MAAM,CAACC,WAAW,CAACC,GAAG,EAAE;AACzD,CAAC;AACW,IAAC+B,cAAc,GAAG,SAAjBA,cAAcA,CAAA,EAAS;EAClCC,SAAS,CAAC,YAAM;IACd,IAAI1F,oBAAoB,KAAK,CAAC,EAAE;MAC9BK,QAAQ,CAACsF,gBAAgB,CAAC,WAAW,EAAEJ,wBAAwB,CAAC;MAChElF,QAAQ,CAACsF,gBAAgB,CAAC,YAAY,EAAEJ,wBAAwB,CAAC;MACjElF,QAAQ,CAACsF,gBAAgB,CAAC,SAAS,EAAEH,wBAAwB,CAAC;IACpE;IACIxF,oBAAoB,EAAE;EAC1B,CAAG,CAAC;EACF4F,eAAe,CAAC,YAAM;IACpB5F,oBAAoB,EAAE;IACtB,IAAIA,oBAAoB,IAAI,CAAC,EAAE;MAC7BK,QAAQ,CAACwF,mBAAmB,CAAC,WAAW,EAAEN,wBAAwB,CAAC;MACnElF,QAAQ,CAACwF,mBAAmB,CAAC,YAAY,EAAEN,wBAAwB,CAAC;MACpElF,QAAQ,CAACwF,mBAAmB,CAAC,SAAS,EAAEL,wBAAwB,CAAC;IACvE;EACA,CAAG,CAAC;EACF,OAAO;IACL5F,WAAW,EAAXA,WAAW;IACXE,sBAAsB,EAAtBA,sBAAsB;IACtBC,2BAA2B,EAA3BA;EACJ,CAAG;AACH;AACY,IAAC+F,4BAA4B,GAAG,SAA/BA,4BAA4BA,CAAIC,MAAM,EAAK;EACtD,OAAO,IAAIC,WAAW,CAACC,kBAAkB,EAAAC,aAAA,CAAAA,aAAA,KACpCC,uBAAuB;IAC1BJ,MAAM,EAANA;EAAM,EACP,CAAC;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}