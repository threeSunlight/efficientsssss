{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { defineComponent, ref, computed, nextTick, provide, reactive, watch, onBeforeUpdate, onMounted, resolveComponent, openBlock, createElementBlock, normalizeClass, Fragment, renderList, createBlock } from 'vue';\nimport { isEqual, flattenDeep, cloneDeep } from 'lodash-unified';\nimport '../../../utils/index.mjs';\nimport '../../../constants/index.mjs';\nimport '../../../hooks/index.mjs';\nimport ElCascaderMenu from './menu.mjs';\nimport Store from './store.mjs';\nimport Node from './node.mjs';\nimport { CommonProps, useCascaderConfig } from './config.mjs';\nimport { sortByOriginalOrder, checkNode, getMenuIndex } from './utils.mjs';\nimport { CASCADER_PANEL_INJECTION_KEY } from './types.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { UPDATE_MODEL_EVENT, CHANGE_EVENT } from '../../../constants/event.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { isEmpty } from '../../../utils/types.mjs';\nimport { unique, castArray } from '../../../utils/arrays.mjs';\nimport { isClient } from '@vueuse/core';\nimport { scrollIntoView } from '../../../utils/dom/scroll.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nimport { focusNode, getSibling } from '../../../utils/dom/aria.mjs';\nvar _sfc_main = defineComponent({\n  name: \"ElCascaderPanel\",\n  components: {\n    ElCascaderMenu: ElCascaderMenu\n  },\n  props: _objectSpread(_objectSpread({}, CommonProps), {}, {\n    border: {\n      type: Boolean,\n      \"default\": true\n    },\n    renderLabel: Function\n  }),\n  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, \"close\", \"expand-change\"],\n  setup: function setup(props, _ref) {\n    var emit = _ref.emit,\n      slots = _ref.slots;\n    var manualChecked = false;\n    var ns = useNamespace(\"cascader\");\n    var config = useCascaderConfig(props);\n    var store = null;\n    var initialLoaded = ref(true);\n    var menuList = ref([]);\n    var checkedValue = ref(null);\n    var menus = ref([]);\n    var expandingNode = ref(null);\n    var checkedNodes = ref([]);\n    var isHoverMenu = computed(function () {\n      return config.value.expandTrigger === \"hover\";\n    });\n    var renderLabelFn = computed(function () {\n      return props.renderLabel || slots[\"default\"];\n    });\n    var initStore = function initStore() {\n      var options = props.options;\n      var cfg = config.value;\n      manualChecked = false;\n      store = new Store(options, cfg);\n      menus.value = [store.getNodes()];\n      if (cfg.lazy && isEmpty(props.options)) {\n        initialLoaded.value = false;\n        lazyLoad(void 0, function (list) {\n          if (list) {\n            store = new Store(list, cfg);\n            menus.value = [store.getNodes()];\n          }\n          initialLoaded.value = true;\n          syncCheckedValue(false, true);\n        });\n      } else {\n        syncCheckedValue(false, true);\n      }\n    };\n    var lazyLoad = function lazyLoad(node, cb) {\n      var cfg = config.value;\n      node = node || new Node({}, cfg, void 0, true);\n      node.loading = true;\n      var resolve = function resolve(dataList) {\n        var _node = node;\n        var parent = _node.root ? null : _node;\n        dataList && (store == null ? void 0 : store.appendNodes(dataList, parent));\n        _node.loading = false;\n        _node.loaded = true;\n        _node.childrenData = _node.childrenData || [];\n        cb && cb(dataList);\n      };\n      cfg.lazyLoad(node, resolve);\n    };\n    var expandNode = function expandNode(node, silent) {\n      var _a;\n      var level = node.level;\n      var newMenus = menus.value.slice(0, level);\n      var newExpandingNode;\n      if (node.isLeaf) {\n        newExpandingNode = node.pathNodes[level - 2];\n      } else {\n        newExpandingNode = node;\n        newMenus.push(node.children);\n      }\n      if (((_a = expandingNode.value) == null ? void 0 : _a.uid) !== (newExpandingNode == null ? void 0 : newExpandingNode.uid)) {\n        expandingNode.value = node;\n        menus.value = newMenus;\n        !silent && emit(\"expand-change\", (node == null ? void 0 : node.pathValues) || []);\n      }\n    };\n    var handleCheckChange = function handleCheckChange(node, checked) {\n      var emitClose = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var _config$value = config.value,\n        checkStrictly = _config$value.checkStrictly,\n        multiple = _config$value.multiple;\n      var oldNode = checkedNodes.value[0];\n      manualChecked = true;\n      !multiple && (oldNode == null ? void 0 : oldNode.doCheck(false));\n      node.doCheck(checked);\n      calculateCheckedValue();\n      emitClose && !multiple && !checkStrictly && emit(\"close\");\n      !emitClose && !multiple && !checkStrictly && expandParentNode(node);\n    };\n    var expandParentNode = function expandParentNode(node) {\n      if (!node) return;\n      node = node.parent;\n      expandParentNode(node);\n      node && expandNode(node);\n    };\n    var getFlattedNodes = function getFlattedNodes(leafOnly) {\n      return store == null ? void 0 : store.getFlattedNodes(leafOnly);\n    };\n    var getCheckedNodes = function getCheckedNodes(leafOnly) {\n      var _a;\n      return (_a = getFlattedNodes(leafOnly)) == null ? void 0 : _a.filter(function (node) {\n        return node.checked !== false;\n      });\n    };\n    var clearCheckedNodes = function clearCheckedNodes() {\n      checkedNodes.value.forEach(function (node) {\n        return node.doCheck(false);\n      });\n      calculateCheckedValue();\n      menus.value = menus.value.slice(0, 1);\n      expandingNode.value = null;\n      emit(\"expand-change\", []);\n    };\n    var calculateCheckedValue = function calculateCheckedValue() {\n      var _a;\n      var _config$value2 = config.value,\n        checkStrictly = _config$value2.checkStrictly,\n        multiple = _config$value2.multiple;\n      var oldNodes = checkedNodes.value;\n      var newNodes = getCheckedNodes(!checkStrictly);\n      var nodes = sortByOriginalOrder(oldNodes, newNodes);\n      var values = nodes.map(function (node) {\n        return node.valueByOption;\n      });\n      checkedNodes.value = nodes;\n      checkedValue.value = multiple ? values : (_a = values[0]) != null ? _a : null;\n    };\n    var syncCheckedValue = function syncCheckedValue() {\n      var loaded = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var forced = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var modelValue = props.modelValue;\n      var _config$value3 = config.value,\n        lazy = _config$value3.lazy,\n        multiple = _config$value3.multiple,\n        checkStrictly = _config$value3.checkStrictly;\n      var leafOnly = !checkStrictly;\n      if (!initialLoaded.value || manualChecked || !forced && isEqual(modelValue, checkedValue.value)) return;\n      if (lazy && !loaded) {\n        var values = unique(flattenDeep(castArray(modelValue)));\n        var nodes = values.map(function (val) {\n          return store == null ? void 0 : store.getNodeByValue(val);\n        }).filter(function (node) {\n          return !!node && !node.loaded && !node.loading;\n        });\n        if (nodes.length) {\n          nodes.forEach(function (node) {\n            lazyLoad(node, function () {\n              return syncCheckedValue(false, forced);\n            });\n          });\n        } else {\n          syncCheckedValue(true, forced);\n        }\n      } else {\n        var _values = multiple ? castArray(modelValue) : [modelValue];\n        var _nodes = unique(_values.map(function (val) {\n          return store == null ? void 0 : store.getNodeByValue(val, leafOnly);\n        }));\n        syncMenuState(_nodes, forced);\n        checkedValue.value = cloneDeep(modelValue);\n      }\n    };\n    var syncMenuState = function syncMenuState(newCheckedNodes) {\n      var reserveExpandingState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var checkStrictly = config.value.checkStrictly;\n      var oldNodes = checkedNodes.value;\n      var newNodes = newCheckedNodes.filter(function (node) {\n        return !!node && (checkStrictly || node.isLeaf);\n      });\n      var oldExpandingNode = store == null ? void 0 : store.getSameNode(expandingNode.value);\n      var newExpandingNode = reserveExpandingState && oldExpandingNode || newNodes[0];\n      if (newExpandingNode) {\n        newExpandingNode.pathNodes.forEach(function (node) {\n          return expandNode(node, true);\n        });\n      } else {\n        expandingNode.value = null;\n      }\n      oldNodes.forEach(function (node) {\n        return node.doCheck(false);\n      });\n      newNodes.forEach(function (node) {\n        return node.doCheck(true);\n      });\n      checkedNodes.value = newNodes;\n      nextTick(scrollToExpandingNode);\n    };\n    var scrollToExpandingNode = function scrollToExpandingNode() {\n      if (!isClient) return;\n      menuList.value.forEach(function (menu) {\n        var menuElement = menu == null ? void 0 : menu.$el;\n        if (menuElement) {\n          var container = menuElement.querySelector(\".\".concat(ns.namespace.value, \"-scrollbar__wrap\"));\n          var activeNode = menuElement.querySelector(\".\".concat(ns.b(\"node\"), \".\").concat(ns.is(\"active\"))) || menuElement.querySelector(\".\".concat(ns.b(\"node\"), \".in-active-path\"));\n          scrollIntoView(container, activeNode);\n        }\n      });\n    };\n    var handleKeyDown = function handleKeyDown(e) {\n      var target = e.target;\n      var code = e.code;\n      switch (code) {\n        case EVENT_CODE.up:\n        case EVENT_CODE.down:\n          {\n            e.preventDefault();\n            var distance = code === EVENT_CODE.up ? -1 : 1;\n            focusNode(getSibling(target, distance, \".\".concat(ns.b(\"node\"), \"[tabindex=\\\"-1\\\"]\")));\n            break;\n          }\n        case EVENT_CODE.left:\n          {\n            e.preventDefault();\n            var preMenu = menuList.value[getMenuIndex(target) - 1];\n            var expandedNode = preMenu == null ? void 0 : preMenu.$el.querySelector(\".\".concat(ns.b(\"node\"), \"[aria-expanded=\\\"true\\\"]\"));\n            focusNode(expandedNode);\n            break;\n          }\n        case EVENT_CODE.right:\n          {\n            e.preventDefault();\n            var nextMenu = menuList.value[getMenuIndex(target) + 1];\n            var firstNode = nextMenu == null ? void 0 : nextMenu.$el.querySelector(\".\".concat(ns.b(\"node\"), \"[tabindex=\\\"-1\\\"]\"));\n            focusNode(firstNode);\n            break;\n          }\n        case EVENT_CODE.enter:\n          checkNode(target);\n          break;\n      }\n    };\n    provide(CASCADER_PANEL_INJECTION_KEY, reactive({\n      config: config,\n      expandingNode: expandingNode,\n      checkedNodes: checkedNodes,\n      isHoverMenu: isHoverMenu,\n      initialLoaded: initialLoaded,\n      renderLabelFn: renderLabelFn,\n      lazyLoad: lazyLoad,\n      expandNode: expandNode,\n      handleCheckChange: handleCheckChange\n    }));\n    watch([config, function () {\n      return props.options;\n    }], initStore, {\n      deep: true,\n      immediate: true\n    });\n    watch(function () {\n      return props.modelValue;\n    }, function () {\n      manualChecked = false;\n      syncCheckedValue();\n    }, {\n      deep: true\n    });\n    watch(function () {\n      return checkedValue.value;\n    }, function (val) {\n      if (!isEqual(val, props.modelValue)) {\n        emit(UPDATE_MODEL_EVENT, val);\n        emit(CHANGE_EVENT, val);\n      }\n    });\n    onBeforeUpdate(function () {\n      return menuList.value = [];\n    });\n    onMounted(function () {\n      return !isEmpty(props.modelValue) && syncCheckedValue();\n    });\n    return {\n      ns: ns,\n      menuList: menuList,\n      menus: menus,\n      checkedNodes: checkedNodes,\n      handleKeyDown: handleKeyDown,\n      handleCheckChange: handleCheckChange,\n      getFlattedNodes: getFlattedNodes,\n      getCheckedNodes: getCheckedNodes,\n      clearCheckedNodes: clearCheckedNodes,\n      calculateCheckedValue: calculateCheckedValue,\n      scrollToExpandingNode: scrollToExpandingNode\n    };\n  }\n});\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_el_cascader_menu = resolveComponent(\"el-cascader-menu\");\n  return openBlock(), createElementBlock(\"div\", {\n    \"class\": normalizeClass([_ctx.ns.b(\"panel\"), _ctx.ns.is(\"bordered\", _ctx.border)]),\n    onKeydown: _cache[0] || (_cache[0] = function () {\n      return _ctx.handleKeyDown && _ctx.handleKeyDown.apply(_ctx, arguments);\n    })\n  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menus, function (menu, index) {\n    return openBlock(), createBlock(_component_el_cascader_menu, {\n      key: index,\n      ref_for: true,\n      ref: function ref(item) {\n        return _ctx.menuList[index] = item;\n      },\n      index: index,\n      nodes: _toConsumableArray(menu)\n    }, null, 8, [\"index\", \"nodes\"]);\n  }), 128))], 34);\n}\nvar CascaderPanel = /* @__PURE__ */_export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/cascader-panel/src/index.vue\"]]);\nexport { CascaderPanel as default };","map":{"version":3,"names":["_sfc_main","defineComponent","name","components","ElCascaderMenu","props","_objectSpread","CommonProps","border","type","Boolean","renderLabel","Function","emits","UPDATE_MODEL_EVENT","CHANGE_EVENT","setup","_ref","emit","slots","manualChecked","ns","useNamespace","config","useCascaderConfig","store","initialLoaded","ref","menuList","checkedValue","menus","expandingNode","checkedNodes","isHoverMenu","computed","value","expandTrigger","renderLabelFn","initStore","options","cfg","Store","getNodes","lazy","isEmpty","lazyLoad","list","syncCheckedValue","node","cb","Node","loading","resolve","dataList","_node","parent","root","appendNodes","loaded","childrenData","expandNode","silent","_a","level","newMenus","slice","newExpandingNode","isLeaf","pathNodes","push","children","uid","pathValues","handleCheckChange","checked","emitClose","arguments","length","undefined","_config$value","checkStrictly","multiple","oldNode","doCheck","calculateCheckedValue","expandParentNode","getFlattedNodes","leafOnly","getCheckedNodes","filter","clearCheckedNodes","forEach","_config$value2","oldNodes","newNodes","nodes","sortByOriginalOrder","values","map","valueByOption","forced","modelValue","_config$value3","isEqual","unique","flattenDeep","castArray","val","getNodeByValue","syncMenuState","cloneDeep","newCheckedNodes","reserveExpandingState","oldExpandingNode","getSameNode","nextTick","scrollToExpandingNode","isClient","menu","menuElement","$el","container","querySelector","concat","namespace","activeNode","b","is","scrollIntoView","handleKeyDown","e","target","code","EVENT_CODE","up","down","preventDefault","distance","focusNode","getSibling","left","preMenu","getMenuIndex","expandedNode","right","nextMenu","firstNode","enter","checkNode","provide","CASCADER_PANEL_INJECTION_KEY","reactive","watch","deep","immediate","onBeforeUpdate","onMounted","_sfc_render","_ctx","_cache","$props","$setup","$data","$options","_component_el_cascader_menu","resolveComponent","openBlock","createElementBlock","normalizeClass","apply","Fragment","renderList","index","createBlock","key","ref_for","item"],"sources":["../../../../../../packages/components/cascader-panel/src/index.vue"],"sourcesContent":["<template>\n  <div\n    :class=\"[ns.b('panel'), ns.is('bordered', border)]\"\n    @keydown=\"handleKeyDown\"\n  >\n    <el-cascader-menu\n      v-for=\"(menu, index) in menus\"\n      :key=\"index\"\n      :ref=\"(item) => (menuList[index] = item)\"\n      :index=\"index\"\n      :nodes=\"[...menu]\"\n    />\n  </div>\n</template>\n\n<script lang=\"ts\">\n// @ts-nocheck\nimport {\n  computed,\n  defineComponent,\n  nextTick,\n  onBeforeUpdate,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  watch,\n} from 'vue'\nimport { cloneDeep, flattenDeep, isEqual } from 'lodash-unified'\nimport {\n  castArray,\n  focusNode,\n  getSibling,\n  isClient,\n  isEmpty,\n  scrollIntoView,\n  unique,\n} from '@element-plus/utils'\nimport {\n  CHANGE_EVENT,\n  EVENT_CODE,\n  UPDATE_MODEL_EVENT,\n} from '@element-plus/constants'\nimport { useNamespace } from '@element-plus/hooks'\n\nimport ElCascaderMenu from './menu.vue'\nimport Store from './store'\nimport Node from './node'\nimport { CommonProps, useCascaderConfig } from './config'\nimport { checkNode, getMenuIndex, sortByOriginalOrder } from './utils'\nimport { CASCADER_PANEL_INJECTION_KEY } from './types'\n\nimport type { PropType } from 'vue'\nimport type { Nullable } from '@element-plus/utils'\nimport type {\n  default as CascaderNode,\n  CascaderNodeValue,\n  CascaderOption,\n  CascaderValue,\n  RenderLabel,\n} from './node'\n\nimport type { ElCascaderPanelContext } from './types'\n\nexport default defineComponent({\n  name: 'ElCascaderPanel',\n\n  components: {\n    ElCascaderMenu,\n  },\n\n  props: {\n    ...CommonProps,\n    border: {\n      type: Boolean,\n      default: true,\n    },\n    renderLabel: Function as PropType<RenderLabel>,\n  },\n\n  emits: [UPDATE_MODEL_EVENT, CHANGE_EVENT, 'close', 'expand-change'],\n\n  setup(props, { emit, slots }) {\n    // for interrupt sync check status in lazy mode\n    let manualChecked = false\n\n    const ns = useNamespace('cascader')\n    const config = useCascaderConfig(props)\n\n    let store: Nullable<Store> = null\n    const initialLoaded = ref(true)\n    const menuList = ref<any[]>([])\n    const checkedValue = ref<Nullable<CascaderValue>>(null)\n    const menus = ref<CascaderNode[][]>([])\n    const expandingNode = ref<Nullable<CascaderNode>>(null)\n    const checkedNodes = ref<CascaderNode[]>([])\n\n    const isHoverMenu = computed(() => config.value.expandTrigger === 'hover')\n    const renderLabelFn = computed(() => props.renderLabel || slots.default)\n\n    const initStore = () => {\n      const { options } = props\n      const cfg = config.value\n\n      manualChecked = false\n      store = new Store(options, cfg)\n      menus.value = [store.getNodes()]\n\n      if (cfg.lazy && isEmpty(props.options)) {\n        initialLoaded.value = false\n        lazyLoad(undefined, (list) => {\n          if (list) {\n            store = new Store(list, cfg)\n            menus.value = [store.getNodes()]\n          }\n          initialLoaded.value = true\n          syncCheckedValue(false, true)\n        })\n      } else {\n        syncCheckedValue(false, true)\n      }\n    }\n\n    const lazyLoad: ElCascaderPanelContext['lazyLoad'] = (node, cb) => {\n      const cfg = config.value\n      node! = node || new Node({}, cfg, undefined, true)\n      node.loading = true\n\n      const resolve = (dataList: CascaderOption[]) => {\n        const _node = node as Node\n        const parent = _node.root ? null : _node\n        dataList && store?.appendNodes(dataList, parent as any)\n        _node.loading = false\n        _node.loaded = true\n        _node.childrenData = _node.childrenData || []\n        cb && cb(dataList)\n      }\n\n      cfg.lazyLoad(node, resolve as any)\n    }\n\n    const expandNode: ElCascaderPanelContext['expandNode'] = (node, silent) => {\n      const { level } = node\n      const newMenus = menus.value.slice(0, level)\n      let newExpandingNode: Nullable<CascaderNode>\n\n      if (node.isLeaf) {\n        newExpandingNode = node.pathNodes[level - 2]\n      } else {\n        newExpandingNode = node\n        newMenus.push(node.children)\n      }\n\n      if (expandingNode.value?.uid !== newExpandingNode?.uid) {\n        expandingNode.value = node\n        menus.value = newMenus\n        !silent && emit('expand-change', node?.pathValues || [])\n      }\n    }\n\n    const handleCheckChange: ElCascaderPanelContext['handleCheckChange'] = (\n      node,\n      checked,\n      emitClose = true\n    ) => {\n      const { checkStrictly, multiple } = config.value\n      const oldNode = checkedNodes.value[0]\n      manualChecked = true\n\n      !multiple && oldNode?.doCheck(false)\n      node.doCheck(checked)\n      calculateCheckedValue()\n      emitClose && !multiple && !checkStrictly && emit('close')\n      !emitClose && !multiple && !checkStrictly && expandParentNode(node)\n    }\n\n    const expandParentNode = (node) => {\n      if (!node) return\n      node = node.parent\n      expandParentNode(node)\n      node && expandNode(node)\n    }\n\n    const getFlattedNodes = (leafOnly: boolean) => {\n      return store?.getFlattedNodes(leafOnly)\n    }\n\n    const getCheckedNodes = (leafOnly: boolean) => {\n      return getFlattedNodes(leafOnly)?.filter((node) => node.checked !== false)\n    }\n\n    const clearCheckedNodes = () => {\n      checkedNodes.value.forEach((node) => node.doCheck(false))\n      calculateCheckedValue()\n      menus.value = menus.value.slice(0, 1)\n      expandingNode.value = null\n      emit('expand-change', [])\n    }\n\n    const calculateCheckedValue = () => {\n      const { checkStrictly, multiple } = config.value\n      const oldNodes = checkedNodes.value\n      const newNodes = getCheckedNodes(!checkStrictly)!\n      // ensure the original order\n      const nodes = sortByOriginalOrder(oldNodes, newNodes)\n      const values = nodes.map((node) => node.valueByOption)\n      checkedNodes.value = nodes\n      checkedValue.value = multiple ? values : values[0] ?? null\n    }\n\n    const syncCheckedValue = (loaded = false, forced = false) => {\n      const { modelValue } = props\n      const { lazy, multiple, checkStrictly } = config.value\n      const leafOnly = !checkStrictly\n\n      if (\n        !initialLoaded.value ||\n        manualChecked ||\n        (!forced && isEqual(modelValue, checkedValue.value))\n      )\n        return\n\n      if (lazy && !loaded) {\n        const values: CascaderNodeValue[] = unique(\n          flattenDeep(castArray(modelValue))\n        )\n        const nodes = values\n          .map((val) => store?.getNodeByValue(val))\n          .filter((node) => !!node && !node.loaded && !node.loading) as Node[]\n\n        if (nodes.length) {\n          nodes.forEach((node) => {\n            lazyLoad(node, () => syncCheckedValue(false, forced))\n          })\n        } else {\n          syncCheckedValue(true, forced)\n        }\n      } else {\n        const values = multiple ? castArray(modelValue) : [modelValue]\n        const nodes = unique(\n          values.map((val) => store?.getNodeByValue(val, leafOnly))\n        ) as Node[]\n        syncMenuState(nodes, forced)\n        checkedValue.value = cloneDeep(modelValue)\n      }\n    }\n\n    const syncMenuState = (\n      newCheckedNodes: CascaderNode[],\n      reserveExpandingState = true\n    ) => {\n      const { checkStrictly } = config.value\n      const oldNodes = checkedNodes.value\n      const newNodes = newCheckedNodes.filter(\n        (node) => !!node && (checkStrictly || node.isLeaf)\n      )\n      const oldExpandingNode = store?.getSameNode(expandingNode.value!)\n      const newExpandingNode =\n        (reserveExpandingState && oldExpandingNode) || newNodes[0]\n\n      if (newExpandingNode) {\n        newExpandingNode.pathNodes.forEach((node) => expandNode(node, true))\n      } else {\n        expandingNode.value = null\n      }\n\n      oldNodes.forEach((node) => node.doCheck(false))\n      newNodes.forEach((node) => node.doCheck(true))\n\n      checkedNodes.value = newNodes\n      nextTick(scrollToExpandingNode)\n    }\n\n    const scrollToExpandingNode = () => {\n      if (!isClient) return\n\n      menuList.value.forEach((menu) => {\n        const menuElement = menu?.$el\n        if (menuElement) {\n          const container = menuElement.querySelector(\n            `.${ns.namespace.value}-scrollbar__wrap`\n          )\n          const activeNode =\n            menuElement.querySelector(`.${ns.b('node')}.${ns.is('active')}`) ||\n            menuElement.querySelector(`.${ns.b('node')}.in-active-path`)\n          scrollIntoView(container, activeNode)\n        }\n      })\n    }\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      const target = e.target as HTMLElement\n      const { code } = e\n\n      switch (code) {\n        case EVENT_CODE.up:\n        case EVENT_CODE.down: {\n          e.preventDefault()\n          const distance = code === EVENT_CODE.up ? -1 : 1\n          focusNode(\n            getSibling(target, distance, `.${ns.b('node')}[tabindex=\"-1\"]`)\n          )\n          break\n        }\n        case EVENT_CODE.left: {\n          e.preventDefault()\n          const preMenu = menuList.value[getMenuIndex(target) - 1]\n          const expandedNode = preMenu?.$el.querySelector(\n            `.${ns.b('node')}[aria-expanded=\"true\"]`\n          )\n          focusNode(expandedNode)\n          break\n        }\n        case EVENT_CODE.right: {\n          e.preventDefault()\n          const nextMenu = menuList.value[getMenuIndex(target) + 1]\n          const firstNode = nextMenu?.$el.querySelector(\n            `.${ns.b('node')}[tabindex=\"-1\"]`\n          )\n          focusNode(firstNode)\n          break\n        }\n        case EVENT_CODE.enter:\n          checkNode(target)\n          break\n      }\n    }\n\n    provide(\n      CASCADER_PANEL_INJECTION_KEY,\n      reactive({\n        config,\n        expandingNode,\n        checkedNodes,\n        isHoverMenu,\n        initialLoaded,\n        renderLabelFn,\n        lazyLoad,\n        expandNode,\n        handleCheckChange,\n      })\n    )\n\n    watch([config, () => props.options], initStore, {\n      deep: true,\n      immediate: true,\n    })\n\n    watch(\n      () => props.modelValue,\n      () => {\n        manualChecked = false\n        syncCheckedValue()\n      },\n      {\n        deep: true,\n      }\n    )\n\n    watch(\n      () => checkedValue.value,\n      (val) => {\n        if (!isEqual(val, props.modelValue)) {\n          emit(UPDATE_MODEL_EVENT, val)\n          emit(CHANGE_EVENT, val)\n        }\n      }\n    )\n\n    onBeforeUpdate(() => (menuList.value = []))\n\n    onMounted(() => !isEmpty(props.modelValue) && syncCheckedValue())\n\n    return {\n      ns,\n      menuList,\n      menus,\n      checkedNodes,\n      handleKeyDown,\n      handleCheckChange,\n      getFlattedNodes,\n      /**\n       * @description get an array of currently selected node,(leafOnly) whether only return the leaf checked nodes, default is `false`\n       */\n      getCheckedNodes,\n      /**\n       * @description clear checked nodes\n       */\n      clearCheckedNodes,\n      calculateCheckedValue,\n      scrollToExpandingNode,\n    }\n  },\n})\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}