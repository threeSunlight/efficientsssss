{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { defineComponent, inject, watch, onBeforeUnmount, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle } from 'vue';\nimport '../../../hooks/index.mjs';\nimport { POPPER_CONTENT_INJECTION_KEY } from './constants.mjs';\nimport { popperArrowProps } from './arrow.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nvar __default__ = defineComponent({\n  name: \"ElPopperArrow\",\n  inheritAttrs: false\n});\nvar _sfc_main = /* @__PURE__ */defineComponent(_objectSpread(_objectSpread({}, __default__), {}, {\n  props: popperArrowProps,\n  setup: function setup(__props, _ref) {\n    var expose = _ref.expose;\n    var props = __props;\n    var ns = useNamespace(\"popper\");\n    var _inject = inject(POPPER_CONTENT_INJECTION_KEY, void 0),\n      arrowOffset = _inject.arrowOffset,\n      arrowRef = _inject.arrowRef,\n      arrowStyle = _inject.arrowStyle;\n    watch(function () {\n      return props.arrowOffset;\n    }, function (val) {\n      arrowOffset.value = val;\n    });\n    onBeforeUnmount(function () {\n      arrowRef.value = void 0;\n    });\n    expose({\n      arrowRef: arrowRef\n    });\n    return function (_ctx, _cache) {\n      return openBlock(), createElementBlock(\"span\", {\n        ref_key: \"arrowRef\",\n        ref: arrowRef,\n        \"class\": normalizeClass(unref(ns).e(\"arrow\")),\n        style: normalizeStyle(unref(arrowStyle)),\n        \"data-popper-arrow\": \"\"\n      }, null, 6);\n    };\n  }\n}));\nvar ElPopperArrow = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/popper/src/arrow.vue\"]]);\nexport { ElPopperArrow as default };","map":{"version":3,"names":["name","inheritAttrs","ns","useNamespace","_inject","inject","POPPER_CONTENT_INJECTION_KEY","arrowOffset","arrowRef","arrowStyle","watch","props","val","value","onBeforeUnmount","expose"],"sources":["../../../../../../packages/components/popper/src/arrow.vue"],"sourcesContent":["<template>\n  <span\n    ref=\"arrowRef\"\n    :class=\"ns.e('arrow')\"\n    :style=\"arrowStyle\"\n    data-popper-arrow\n  />\n</template>\n\n<script lang=\"ts\" setup>\nimport { inject, onBeforeUnmount, watch } from 'vue'\nimport { useNamespace } from '@element-plus/hooks'\nimport { POPPER_CONTENT_INJECTION_KEY } from './constants'\nimport { popperArrowProps } from './arrow'\n\ndefineOptions({\n  name: 'ElPopperArrow',\n  inheritAttrs: false,\n})\n\nconst props = defineProps(popperArrowProps)\n\nconst ns = useNamespace('popper')\nconst { arrowOffset, arrowRef, arrowStyle } = inject(\n  POPPER_CONTENT_INJECTION_KEY,\n  undefined\n)!\n\nwatch(\n  () => props.arrowOffset,\n  (val) => {\n    arrowOffset.value = val\n  }\n)\nonBeforeUnmount(() => {\n  arrowRef.value = undefined\n})\n\ndefineExpose({\n  /**\n   * @description Arrow element\n   */\n  arrowRef,\n})\n</script>\n"],"mappings":";;;;;;;;;;;;iCAec;EACZA,IAAM;EACNC,YAAc;AAChB;;;;;;IAIM,IAAAC,EAAA,GAAKC,YAAA,CAAa,QAAQ;IAChC,IAAAC,OAAA,GAA8CC,MAAA,CAC5CC,4BAAA,EACA,KACF;MAHQC,WAAa,GAAAH,OAAA,CAAbG,WAAa;MAAAC,QAAA,GAAAJ,OAAA,CAAAI,QAAA;MAAUC,UAAe,GAAAL,OAAA,CAAfK,UAAe;IAK9CC,KAAA,CACE;MAAA,OAAMC,KAAA,CAAMJ,WACZ;IAAA,aAACK,GAAQ;MACPL,WAAA,CAAYM,KAAQ,GAAAD,GAAA;IAAA,CAExB;IACAE,eAAA,CAAgB,YAAM;MACpBN,QAAA,CAASK,KAAQ;IAAA,CAClB;IAEYE,MAAA;MAIXP,QAAA,EAAAA;IAAA,CACD"},"metadata":{},"sourceType":"module","externalDependencies":[]}