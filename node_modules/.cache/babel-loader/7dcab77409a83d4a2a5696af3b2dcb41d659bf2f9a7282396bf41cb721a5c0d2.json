{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nimport { defineComponent, shallowRef, ref, computed, watch, onMounted, watchEffect, openBlock, createElementBlock, normalizeClass, unref, normalizeStyle, createElementVNode, renderSlot } from 'vue';\nimport { useWindowSize, useElementBounding, useEventListener } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../hooks/index.mjs';\nimport { affixProps, affixEmits } from './affix.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { addUnit } from '../../../utils/dom/style.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport { getScrollContainer } from '../../../utils/dom/scroll.mjs';\nvar COMPONENT_NAME = \"ElAffix\";\nvar __default__ = defineComponent({\n  name: COMPONENT_NAME\n});\nvar _sfc_main = /* @__PURE__ */defineComponent(_objectSpread(_objectSpread({}, __default__), {}, {\n  props: affixProps,\n  emits: affixEmits,\n  setup: function setup(__props, _ref) {\n    var expose = _ref.expose,\n      emit = _ref.emit;\n    var props = __props;\n    var ns = useNamespace(\"affix\");\n    var target = shallowRef();\n    var root = shallowRef();\n    var scrollContainer = shallowRef();\n    var _useWindowSize = useWindowSize(),\n      windowHeight = _useWindowSize.height;\n    var _useElementBounding = useElementBounding(root, {\n        windowScroll: false\n      }),\n      rootHeight = _useElementBounding.height,\n      rootWidth = _useElementBounding.width,\n      rootTop = _useElementBounding.top,\n      rootBottom = _useElementBounding.bottom,\n      updateRoot = _useElementBounding.update;\n    var targetRect = useElementBounding(target);\n    var fixed = ref(false);\n    var scrollTop = ref(0);\n    var transform = ref(0);\n    var rootStyle = computed(function () {\n      return {\n        height: fixed.value ? \"\".concat(rootHeight.value, \"px\") : \"\",\n        width: fixed.value ? \"\".concat(rootWidth.value, \"px\") : \"\"\n      };\n    });\n    var affixStyle = computed(function () {\n      if (!fixed.value) return {};\n      var offset = props.offset ? addUnit(props.offset) : 0;\n      return {\n        height: \"\".concat(rootHeight.value, \"px\"),\n        width: \"\".concat(rootWidth.value, \"px\"),\n        top: props.position === \"top\" ? offset : \"\",\n        bottom: props.position === \"bottom\" ? offset : \"\",\n        transform: transform.value ? \"translateY(\".concat(transform.value, \"px)\") : \"\",\n        zIndex: props.zIndex\n      };\n    });\n    var update = function update() {\n      if (!scrollContainer.value) return;\n      scrollTop.value = scrollContainer.value instanceof Window ? document.documentElement.scrollTop : scrollContainer.value.scrollTop || 0;\n      if (props.position === \"top\") {\n        if (props.target) {\n          var difference = targetRect.bottom.value - props.offset - rootHeight.value;\n          fixed.value = props.offset > rootTop.value && targetRect.bottom.value > 0;\n          transform.value = difference < 0 ? difference : 0;\n        } else {\n          fixed.value = props.offset > rootTop.value;\n        }\n      } else if (props.target) {\n        var _difference = windowHeight.value - targetRect.top.value - props.offset - rootHeight.value;\n        fixed.value = windowHeight.value - props.offset < rootBottom.value && windowHeight.value > targetRect.top.value;\n        transform.value = _difference < 0 ? -_difference : 0;\n      } else {\n        fixed.value = windowHeight.value - props.offset < rootBottom.value;\n      }\n    };\n    var handleScroll = function handleScroll() {\n      updateRoot();\n      emit(\"scroll\", {\n        scrollTop: scrollTop.value,\n        fixed: fixed.value\n      });\n    };\n    watch(fixed, function (val) {\n      return emit(\"change\", val);\n    });\n    onMounted(function () {\n      var _a;\n      if (props.target) {\n        target.value = (_a = document.querySelector(props.target)) != null ? _a : void 0;\n        if (!target.value) throwError(COMPONENT_NAME, \"Target is not existed: \".concat(props.target));\n      } else {\n        target.value = document.documentElement;\n      }\n      scrollContainer.value = getScrollContainer(root.value, true);\n      updateRoot();\n    });\n    useEventListener(scrollContainer, \"scroll\", handleScroll);\n    watchEffect(update);\n    expose({\n      update: update,\n      updateRoot: updateRoot\n    });\n    return function (_ctx, _cache) {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"root\",\n        ref: root,\n        \"class\": normalizeClass(unref(ns).b()),\n        style: normalizeStyle(unref(rootStyle))\n      }, [createElementVNode(\"div\", {\n        \"class\": normalizeClass(_defineProperty({}, unref(ns).m(\"fixed\"), fixed.value)),\n        style: normalizeStyle(unref(affixStyle))\n      }, [renderSlot(_ctx.$slots, \"default\")], 6)], 6);\n    };\n  }\n}));\nvar Affix = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/affix/src/affix.vue\"]]);\nexport { Affix as default };","map":{"version":3,"names":["name","COMPONENT_NAME","ns","useNamespace","target","shallowRef","root","scrollContainer","_useWindowSize","useWindowSize","windowHeight","height","_useElementBounding","useElementBounding","windowScroll","rootHeight","rootWidth","width","rootTop","top","rootBottom","bottom","updateRoot","update","targetRect","fixed","ref","scrollTop","transform","rootStyle","computed","value","concat","affixStyle","offset","props","addUnit","position","zIndex","Window","document","documentElement","difference","handleScroll","emit","watch","val","onMounted","_a","querySelector","throwError","getScrollContainer","useEventListener","watchEffect","expose"],"sources":["../../../../../../packages/components/affix/src/affix.vue"],"sourcesContent":["<template>\n  <div ref=\"root\" :class=\"ns.b()\" :style=\"rootStyle\">\n    <div :class=\"{ [ns.m('fixed')]: fixed }\" :style=\"affixStyle\">\n      <slot />\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { computed, onMounted, ref, shallowRef, watch, watchEffect } from 'vue'\nimport {\n  useElementBounding,\n  useEventListener,\n  useWindowSize,\n} from '@vueuse/core'\nimport { addUnit, getScrollContainer, throwError } from '@element-plus/utils'\nimport { useNamespace } from '@element-plus/hooks'\nimport { affixEmits, affixProps } from './affix'\nimport type { CSSProperties } from 'vue'\n\nconst COMPONENT_NAME = 'ElAffix'\ndefineOptions({\n  name: COMPONENT_NAME,\n})\n\nconst props = defineProps(affixProps)\nconst emit = defineEmits(affixEmits)\n\nconst ns = useNamespace('affix')\n\nconst target = shallowRef<HTMLElement>()\nconst root = shallowRef<HTMLDivElement>()\nconst scrollContainer = shallowRef<HTMLElement | Window>()\nconst { height: windowHeight } = useWindowSize()\nconst {\n  height: rootHeight,\n  width: rootWidth,\n  top: rootTop,\n  bottom: rootBottom,\n  update: updateRoot,\n} = useElementBounding(root, { windowScroll: false })\nconst targetRect = useElementBounding(target)\n\nconst fixed = ref(false)\nconst scrollTop = ref(0)\nconst transform = ref(0)\n\nconst rootStyle = computed<CSSProperties>(() => {\n  return {\n    height: fixed.value ? `${rootHeight.value}px` : '',\n    width: fixed.value ? `${rootWidth.value}px` : '',\n  }\n})\n\nconst affixStyle = computed<CSSProperties>(() => {\n  if (!fixed.value) return {}\n\n  const offset = props.offset ? addUnit(props.offset) : 0\n  return {\n    height: `${rootHeight.value}px`,\n    width: `${rootWidth.value}px`,\n    top: props.position === 'top' ? offset : '',\n    bottom: props.position === 'bottom' ? offset : '',\n    transform: transform.value ? `translateY(${transform.value}px)` : '',\n    zIndex: props.zIndex,\n  }\n})\n\nconst update = () => {\n  if (!scrollContainer.value) return\n\n  scrollTop.value =\n    scrollContainer.value instanceof Window\n      ? document.documentElement.scrollTop\n      : scrollContainer.value.scrollTop || 0\n\n  if (props.position === 'top') {\n    if (props.target) {\n      const difference =\n        targetRect.bottom.value - props.offset - rootHeight.value\n      fixed.value = props.offset > rootTop.value && targetRect.bottom.value > 0\n      transform.value = difference < 0 ? difference : 0\n    } else {\n      fixed.value = props.offset > rootTop.value\n    }\n  } else if (props.target) {\n    const difference =\n      windowHeight.value -\n      targetRect.top.value -\n      props.offset -\n      rootHeight.value\n    fixed.value =\n      windowHeight.value - props.offset < rootBottom.value &&\n      windowHeight.value > targetRect.top.value\n    transform.value = difference < 0 ? -difference : 0\n  } else {\n    fixed.value = windowHeight.value - props.offset < rootBottom.value\n  }\n}\n\nconst handleScroll = () => {\n  updateRoot()\n  emit('scroll', {\n    scrollTop: scrollTop.value,\n    fixed: fixed.value,\n  })\n}\n\nwatch(fixed, (val) => emit('change', val))\n\nonMounted(() => {\n  if (props.target) {\n    target.value =\n      document.querySelector<HTMLElement>(props.target) ?? undefined\n    if (!target.value)\n      throwError(COMPONENT_NAME, `Target is not existed: ${props.target}`)\n  } else {\n    target.value = document.documentElement\n  }\n  scrollContainer.value = getScrollContainer(root.value!, true)\n  updateRoot()\n})\n\nuseEventListener(scrollContainer, 'scroll', handleScroll)\nwatchEffect(update)\n\ndefineExpose({\n  /** @description update affix status */\n  update,\n  /** @description update rootRect info */\n  updateRoot,\n})\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}