{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nimport { defineComponent, getCurrentInstance, inject, ref, computed, nextTick, watch, onMounted, onUpdated, createVNode } from 'vue';\nimport { useDocumentVisibility, useWindowFocus, useResizeObserver } from '@vueuse/core';\nimport '../../../utils/index.mjs';\nimport '../../../constants/index.mjs';\nimport { ElIcon } from '../../icon/index.mjs';\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue';\nimport '../../../hooks/index.mjs';\nimport TabBar from './tab-bar2.mjs';\nimport { tabsRootContextKey } from './constants.mjs';\nimport { buildProps, definePropType } from '../../../utils/vue/props/runtime.mjs';\nimport { mutable } from '../../../utils/typescript.mjs';\nimport { throwError } from '../../../utils/error.mjs';\nimport { useNamespace } from '../../../hooks/use-namespace/index.mjs';\nimport { capitalize } from '../../../utils/strings.mjs';\nimport { EVENT_CODE } from '../../../constants/aria.mjs';\nvar tabNavProps = buildProps({\n  panes: {\n    type: definePropType(Array),\n    \"default\": function _default() {\n      return mutable([]);\n    }\n  },\n  currentName: {\n    type: [String, Number],\n    \"default\": \"\"\n  },\n  editable: Boolean,\n  type: {\n    type: String,\n    values: [\"card\", \"border-card\", \"\"],\n    \"default\": \"\"\n  },\n  stretch: Boolean\n});\nvar tabNavEmits = {\n  tabClick: function tabClick(tab, tabName, ev) {\n    return ev instanceof Event;\n  },\n  tabRemove: function tabRemove(tab, ev) {\n    return ev instanceof Event;\n  }\n};\nvar COMPONENT_NAME = \"ElTabNav\";\nvar TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n  emits: tabNavEmits,\n  setup: function setup(props, _ref) {\n    var expose = _ref.expose,\n      emit = _ref.emit;\n    var vm = getCurrentInstance();\n    var rootTabs = inject(tabsRootContextKey);\n    if (!rootTabs) throwError(COMPONENT_NAME, \"<el-tabs><tab-nav /></el-tabs>\");\n    var ns = useNamespace(\"tabs\");\n    var visibility = useDocumentVisibility();\n    var focused = useWindowFocus();\n    var navScroll$ = ref();\n    var nav$ = ref();\n    var el$ = ref();\n    var tabBarRef = ref();\n    var scrollable = ref(false);\n    var navOffset = ref(0);\n    var isFocus = ref(false);\n    var focusable = ref(true);\n    var sizeName = computed(function () {\n      return [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition) ? \"width\" : \"height\";\n    });\n    var navStyle = computed(function () {\n      var dir = sizeName.value === \"width\" ? \"X\" : \"Y\";\n      return {\n        transform: \"translate\".concat(dir, \"(-\").concat(navOffset.value, \"px)\")\n      };\n    });\n    var scrollPrev = function scrollPrev() {\n      if (!navScroll$.value) return;\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n      if (!currentOffset) return;\n      var newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;\n      navOffset.value = newOffset;\n    };\n    var scrollNext = function scrollNext() {\n      if (!navScroll$.value || !nav$.value) return;\n      var navSize = nav$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n      if (navSize - currentOffset <= containerSize) return;\n      var newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;\n      navOffset.value = newOffset;\n    };\n    var scrollToActiveTab = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var nav, activeTab, navScroll, isHorizontal, activeTabBounding, navScrollBounding, maxOffset, currentOffset, newOffset;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              nav = nav$.value;\n              if (!(!scrollable.value || !el$.value || !navScroll$.value || !nav)) {\n                _context.next = 3;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 3:\n              _context.next = 5;\n              return nextTick();\n            case 5:\n              activeTab = el$.value.querySelector(\".is-active\");\n              if (activeTab) {\n                _context.next = 8;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 8:\n              navScroll = navScroll$.value;\n              isHorizontal = [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition);\n              activeTabBounding = activeTab.getBoundingClientRect();\n              navScrollBounding = navScroll.getBoundingClientRect();\n              maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;\n              currentOffset = navOffset.value;\n              newOffset = currentOffset;\n              if (isHorizontal) {\n                if (activeTabBounding.left < navScrollBounding.left) {\n                  newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);\n                }\n                if (activeTabBounding.right > navScrollBounding.right) {\n                  newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;\n                }\n              } else {\n                if (activeTabBounding.top < navScrollBounding.top) {\n                  newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);\n                }\n                if (activeTabBounding.bottom > navScrollBounding.bottom) {\n                  newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);\n                }\n              }\n              newOffset = Math.max(newOffset, 0);\n              navOffset.value = Math.min(newOffset, maxOffset);\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function scrollToActiveTab() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    var update = function update() {\n      var _a;\n      if (!nav$.value || !navScroll$.value) return;\n      props.stretch && ((_a = tabBarRef.value) == null ? void 0 : _a.update());\n      var navSize = nav$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var containerSize = navScroll$.value[\"offset\".concat(capitalize(sizeName.value))];\n      var currentOffset = navOffset.value;\n      if (containerSize < navSize) {\n        scrollable.value = scrollable.value || {};\n        scrollable.value.prev = currentOffset;\n        scrollable.value.next = currentOffset + containerSize < navSize;\n        if (navSize - currentOffset < containerSize) {\n          navOffset.value = navSize - containerSize;\n        }\n      } else {\n        scrollable.value = false;\n        if (currentOffset > 0) {\n          navOffset.value = 0;\n        }\n      }\n    };\n    var changeTab = function changeTab(e) {\n      var code = e.code;\n      var up = EVENT_CODE.up,\n        down = EVENT_CODE.down,\n        left = EVENT_CODE.left,\n        right = EVENT_CODE.right;\n      if (![up, down, left, right].includes(code)) return;\n      var tabList = Array.from(e.currentTarget.querySelectorAll(\"[role=tab]:not(.is-disabled)\"));\n      var currentIndex = tabList.indexOf(e.target);\n      var nextIndex;\n      if (code === left || code === up) {\n        if (currentIndex === 0) {\n          nextIndex = tabList.length - 1;\n        } else {\n          nextIndex = currentIndex - 1;\n        }\n      } else {\n        if (currentIndex < tabList.length - 1) {\n          nextIndex = currentIndex + 1;\n        } else {\n          nextIndex = 0;\n        }\n      }\n      tabList[nextIndex].focus({\n        preventScroll: true\n      });\n      tabList[nextIndex].click();\n      setFocus();\n    };\n    var setFocus = function setFocus() {\n      if (focusable.value) isFocus.value = true;\n    };\n    var removeFocus = function removeFocus() {\n      return isFocus.value = false;\n    };\n    watch(visibility, function (visibility2) {\n      if (visibility2 === \"hidden\") {\n        focusable.value = false;\n      } else if (visibility2 === \"visible\") {\n        setTimeout(function () {\n          return focusable.value = true;\n        }, 50);\n      }\n    });\n    watch(focused, function (focused2) {\n      if (focused2) {\n        setTimeout(function () {\n          return focusable.value = true;\n        }, 50);\n      } else {\n        focusable.value = false;\n      }\n    });\n    useResizeObserver(el$, update);\n    onMounted(function () {\n      return setTimeout(function () {\n        return scrollToActiveTab();\n      }, 0);\n    });\n    onUpdated(function () {\n      return update();\n    });\n    expose({\n      scrollToActiveTab: scrollToActiveTab,\n      removeFocus: removeFocus\n    });\n    watch(function () {\n      return props.panes;\n    }, function () {\n      return vm.update();\n    }, {\n      flush: \"post\",\n      deep: true\n    });\n    return function () {\n      var scrollBtn = scrollable.value ? [createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-prev\"), ns.is(\"disabled\", !scrollable.value.prev)],\n        \"onClick\": scrollPrev\n      }, [createVNode(ElIcon, null, {\n        \"default\": function _default() {\n          return [createVNode(ArrowLeft, null, null)];\n        }\n      })]), createVNode(\"span\", {\n        \"class\": [ns.e(\"nav-next\"), ns.is(\"disabled\", !scrollable.value.next)],\n        \"onClick\": scrollNext\n      }, [createVNode(ElIcon, null, {\n        \"default\": function _default() {\n          return [createVNode(ArrowRight, null, null)];\n        }\n      })])] : null;\n      var tabs = props.panes.map(function (pane, index) {\n        var _a, _b, _c, _d;\n        var uid = pane.uid;\n        var disabled = pane.props.disabled;\n        var tabName = (_b = (_a = pane.props.name) != null ? _a : pane.index) != null ? _b : \"\".concat(index);\n        var closable = !disabled && (pane.isClosable || props.editable);\n        pane.index = \"\".concat(index);\n        var btnClose = closable ? createVNode(ElIcon, {\n          \"class\": \"is-icon-close\",\n          \"onClick\": function onClick(ev) {\n            return emit(\"tabRemove\", pane, ev);\n          }\n        }, {\n          \"default\": function _default() {\n            return [createVNode(Close, null, null)];\n          }\n        }) : null;\n        var tabLabelContent = ((_d = (_c = pane.slots).label) == null ? void 0 : _d.call(_c)) || pane.props.label;\n        var tabindex = !disabled && pane.active ? 0 : -1;\n        return createVNode(\"div\", {\n          \"ref\": \"tab-\".concat(uid),\n          \"class\": [ns.e(\"item\"), ns.is(rootTabs.props.tabPosition), ns.is(\"active\", pane.active), ns.is(\"disabled\", disabled), ns.is(\"closable\", closable), ns.is(\"focus\", isFocus.value)],\n          \"id\": \"tab-\".concat(tabName),\n          \"key\": \"tab-\".concat(uid),\n          \"aria-controls\": \"pane-\".concat(tabName),\n          \"role\": \"tab\",\n          \"aria-selected\": pane.active,\n          \"tabindex\": tabindex,\n          \"onFocus\": function onFocus() {\n            return setFocus();\n          },\n          \"onBlur\": function onBlur() {\n            return removeFocus();\n          },\n          \"onClick\": function onClick(ev) {\n            removeFocus();\n            emit(\"tabClick\", pane, tabName, ev);\n          },\n          \"onKeydown\": function onKeydown(ev) {\n            if (closable && (ev.code === EVENT_CODE[\"delete\"] || ev.code === EVENT_CODE.backspace)) {\n              emit(\"tabRemove\", pane, ev);\n            }\n          }\n        }, [tabLabelContent, btnClose].concat());\n      });\n      return createVNode(\"div\", {\n        \"ref\": el$,\n        \"class\": [ns.e(\"nav-wrap\"), ns.is(\"scrollable\", !!scrollable.value), ns.is(rootTabs.props.tabPosition)]\n      }, [scrollBtn, createVNode(\"div\", {\n        \"class\": ns.e(\"nav-scroll\"),\n        \"ref\": navScroll$\n      }, [createVNode(\"div\", {\n        \"class\": [ns.e(\"nav\"), ns.is(rootTabs.props.tabPosition), ns.is(\"stretch\", props.stretch && [\"top\", \"bottom\"].includes(rootTabs.props.tabPosition))],\n        \"ref\": nav$,\n        \"style\": navStyle.value,\n        \"role\": \"tablist\",\n        \"onKeydown\": changeTab\n      }, [!props.type ? createVNode(TabBar, {\n        \"ref\": tabBarRef,\n        \"tabs\": _toConsumableArray(props.panes)\n      }, null) : null, tabs].concat())])]);\n    };\n  }\n});\nexport { TabNav as default, tabNavEmits, tabNavProps };","map":{"version":3,"names":["tabNavProps","buildProps","panes","type","definePropType","Array","_default","mutable","currentName","String","Number","editable","Boolean","values","stretch","tabNavEmits","tabClick","tab","tabName","ev","Event","tabRemove","COMPONENT_NAME","TabNav","defineComponent","name","props","emits","expose","_ref","emit","vm","getCurrentInstance","rootTabs","inject","tabsRootContextKey","throwError","ns","useNamespace","visibility","useDocumentVisibility","focused","useWindowFocus","navScroll$","ref","nav$","el$","tabBarRef","scrollable","navOffset","isFocus","focusable","sizeName","computed","includes","tabPosition","navStyle","dir","value","transform","concat","containerSize","capitalize","currentOffset","newOffset","scrollNext","navSize","scrollToActiveTab","_ref2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","nav","activeTab","navScroll","isHorizontal","activeTabBounding","navScrollBounding","maxOffset","wrap","_callee$","_context","prev","next","abrupt","nextTick","querySelector","getBoundingClientRect","left","right","top","bottom","Math","min","stop","apply","arguments","update","_a","changeTab","e","code","EVENT_CODE","down","up","tabList","from","currentTarget","querySelectorAll","currentIndex","indexOf","target","nextIndex","length","focus","preventScroll","click","setFocus","removeFocus","watch","visibility2","focused2","setTimeout","useResizeObserver","flush","scrollBtn","createVNode","is","scrollPrev","ElIcon","ArrowLeft","ArrowRight","tabs","map","pane","index","_b","_c","_d","uid","disabled","closable","isClosable","btnClose","onClick","Close","tabLabelContent","slots","label","call","tabindex","active","onFocus","onBlur","onKeydown","backspace","TabBar","_toConsumableArray"],"sources":["../../../../../../packages/components/tabs/src/tab-nav.tsx"],"sourcesContent":["import {\n  computed,\n  defineComponent,\n  getCurrentInstance,\n  inject,\n  nextTick,\n  onMounted,\n  onUpdated,\n  ref,\n  watch,\n} from 'vue'\nimport {\n  useDocumentVisibility,\n  useResizeObserver,\n  useWindowFocus,\n} from '@vueuse/core'\nimport {\n  buildProps,\n  capitalize,\n  definePropType,\n  mutable,\n  throwError,\n} from '@element-plus/utils'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { ElIcon } from '@element-plus/components/icon'\nimport { ArrowLeft, ArrowRight, Close } from '@element-plus/icons-vue'\nimport { useNamespace } from '@element-plus/hooks'\nimport TabBar from './tab-bar.vue'\nimport { tabsRootContextKey } from './constants'\n\nimport type { CSSProperties, ExtractPropTypes } from 'vue'\nimport type { TabsPaneContext } from './constants'\nimport type { TabPaneName } from './tabs'\n\ninterface Scrollable {\n  next?: boolean\n  prev?: number\n}\n\nexport const tabNavProps = buildProps({\n  panes: {\n    type: definePropType<TabsPaneContext[]>(Array),\n    default: () => mutable([] as const),\n  },\n  currentName: {\n    type: [String, Number],\n    default: '',\n  },\n  editable: Boolean,\n  type: {\n    type: String,\n    values: ['card', 'border-card', ''],\n    default: '',\n  },\n  stretch: Boolean,\n} as const)\n\nexport const tabNavEmits = {\n  tabClick: (tab: TabsPaneContext, tabName: TabPaneName, ev: Event) =>\n    ev instanceof Event,\n  tabRemove: (tab: TabsPaneContext, ev: Event) => ev instanceof Event,\n}\n\nexport type TabNavProps = ExtractPropTypes<typeof tabNavProps>\nexport type TabNavEmits = typeof tabNavEmits\n\nconst COMPONENT_NAME = 'ElTabNav'\nconst TabNav = defineComponent({\n  name: COMPONENT_NAME,\n  props: tabNavProps,\n  emits: tabNavEmits,\n  setup(props, { expose, emit }) {\n    const vm = getCurrentInstance()!\n\n    const rootTabs = inject(tabsRootContextKey)\n    if (!rootTabs) throwError(COMPONENT_NAME, `<el-tabs><tab-nav /></el-tabs>`)\n\n    const ns = useNamespace('tabs')\n    const visibility = useDocumentVisibility()\n    const focused = useWindowFocus()\n\n    const navScroll$ = ref<HTMLDivElement>()\n    const nav$ = ref<HTMLDivElement>()\n    const el$ = ref<HTMLDivElement>()\n\n    const tabBarRef = ref<InstanceType<typeof TabBar>>()\n\n    const scrollable = ref<false | Scrollable>(false)\n    const navOffset = ref(0)\n    const isFocus = ref(false)\n    const focusable = ref(true)\n\n    const sizeName = computed(() =>\n      ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n        ? 'width'\n        : 'height'\n    )\n    const navStyle = computed<CSSProperties>(() => {\n      const dir = sizeName.value === 'width' ? 'X' : 'Y'\n      return {\n        transform: `translate${dir}(-${navOffset.value}px)`,\n      }\n    })\n\n    const scrollPrev = () => {\n      if (!navScroll$.value) return\n\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (!currentOffset) return\n\n      const newOffset =\n        currentOffset > containerSize ? currentOffset - containerSize : 0\n\n      navOffset.value = newOffset\n    }\n\n    const scrollNext = () => {\n      if (!navScroll$.value || !nav$.value) return\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (navSize - currentOffset <= containerSize) return\n\n      const newOffset =\n        navSize - currentOffset > containerSize * 2\n          ? currentOffset + containerSize\n          : navSize - containerSize\n\n      navOffset.value = newOffset\n    }\n\n    const scrollToActiveTab = async () => {\n      const nav = nav$.value\n      if (!scrollable.value || !el$.value || !navScroll$.value || !nav) return\n\n      await nextTick()\n\n      const activeTab = el$.value.querySelector('.is-active')\n      if (!activeTab) return\n\n      const navScroll = navScroll$.value\n      const isHorizontal = ['top', 'bottom'].includes(\n        rootTabs.props.tabPosition\n      )\n      const activeTabBounding = activeTab.getBoundingClientRect()\n      const navScrollBounding = navScroll.getBoundingClientRect()\n      const maxOffset = isHorizontal\n        ? nav.offsetWidth - navScrollBounding.width\n        : nav.offsetHeight - navScrollBounding.height\n      const currentOffset = navOffset.value\n      let newOffset = currentOffset\n\n      if (isHorizontal) {\n        if (activeTabBounding.left < navScrollBounding.left) {\n          newOffset =\n            currentOffset - (navScrollBounding.left - activeTabBounding.left)\n        }\n        if (activeTabBounding.right > navScrollBounding.right) {\n          newOffset =\n            currentOffset + activeTabBounding.right - navScrollBounding.right\n        }\n      } else {\n        if (activeTabBounding.top < navScrollBounding.top) {\n          newOffset =\n            currentOffset - (navScrollBounding.top - activeTabBounding.top)\n        }\n        if (activeTabBounding.bottom > navScrollBounding.bottom) {\n          newOffset =\n            currentOffset +\n            (activeTabBounding.bottom - navScrollBounding.bottom)\n        }\n      }\n      newOffset = Math.max(newOffset, 0)\n      navOffset.value = Math.min(newOffset, maxOffset)\n    }\n\n    const update = () => {\n      if (!nav$.value || !navScroll$.value) return\n\n      props.stretch && tabBarRef.value?.update()\n\n      const navSize = nav$.value[`offset${capitalize(sizeName.value)}`]\n      const containerSize =\n        navScroll$.value[`offset${capitalize(sizeName.value)}`]\n      const currentOffset = navOffset.value\n\n      if (containerSize < navSize) {\n        scrollable.value = scrollable.value || {}\n        scrollable.value.prev = currentOffset\n        scrollable.value.next = currentOffset + containerSize < navSize\n        if (navSize - currentOffset < containerSize) {\n          navOffset.value = navSize - containerSize\n        }\n      } else {\n        scrollable.value = false\n        if (currentOffset > 0) {\n          navOffset.value = 0\n        }\n      }\n    }\n\n    const changeTab = (e: KeyboardEvent) => {\n      const code = e.code\n\n      const { up, down, left, right } = EVENT_CODE\n      if (![up, down, left, right].includes(code)) return\n\n      // 左右上下键更换tab\n      const tabList = Array.from(\n        (e.currentTarget as HTMLDivElement).querySelectorAll<HTMLDivElement>(\n          '[role=tab]:not(.is-disabled)'\n        )\n      )\n      const currentIndex = tabList.indexOf(e.target as HTMLDivElement)\n\n      let nextIndex: number\n      if (code === left || code === up) {\n        // left\n        if (currentIndex === 0) {\n          // first\n          nextIndex = tabList.length - 1\n        } else {\n          nextIndex = currentIndex - 1\n        }\n      } else {\n        // right\n        if (currentIndex < tabList.length - 1) {\n          // not last\n          nextIndex = currentIndex + 1\n        } else {\n          nextIndex = 0\n        }\n      }\n      tabList[nextIndex].focus({ preventScroll: true }) // 改变焦点元素\n      tabList[nextIndex].click() // 选中下一个tab\n      setFocus()\n    }\n\n    const setFocus = () => {\n      if (focusable.value) isFocus.value = true\n    }\n    const removeFocus = () => (isFocus.value = false)\n\n    watch(visibility, (visibility) => {\n      if (visibility === 'hidden') {\n        focusable.value = false\n      } else if (visibility === 'visible') {\n        setTimeout(() => (focusable.value = true), 50)\n      }\n    })\n    watch(focused, (focused) => {\n      if (focused) {\n        setTimeout(() => (focusable.value = true), 50)\n      } else {\n        focusable.value = false\n      }\n    })\n\n    useResizeObserver(el$, update)\n\n    onMounted(() => setTimeout(() => scrollToActiveTab(), 0))\n    onUpdated(() => update())\n\n    expose({\n      scrollToActiveTab,\n      removeFocus,\n    })\n\n    watch(\n      () => props.panes,\n      () => vm.update(),\n      { flush: 'post', deep: true }\n    )\n\n    return () => {\n      const scrollBtn = scrollable.value\n        ? [\n            <span\n              class={[\n                ns.e('nav-prev'),\n                ns.is('disabled', !scrollable.value.prev),\n              ]}\n              onClick={scrollPrev}\n            >\n              <ElIcon>\n                <ArrowLeft />\n              </ElIcon>\n            </span>,\n            <span\n              class={[\n                ns.e('nav-next'),\n                ns.is('disabled', !scrollable.value.next),\n              ]}\n              onClick={scrollNext}\n            >\n              <ElIcon>\n                <ArrowRight />\n              </ElIcon>\n            </span>,\n          ]\n        : null\n\n      const tabs = props.panes.map((pane, index) => {\n        const uid = pane.uid\n        const disabled = pane.props.disabled\n        const tabName = pane.props.name ?? pane.index ?? `${index}`\n        const closable = !disabled && (pane.isClosable || props.editable)\n        pane.index = `${index}`\n\n        const btnClose = closable ? (\n          <ElIcon\n            class=\"is-icon-close\"\n            // `onClick` not exist when generate dts\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            onClick={(ev: MouseEvent) => emit('tabRemove', pane, ev)}\n          >\n            <Close />\n          </ElIcon>\n        ) : null\n\n        const tabLabelContent = pane.slots.label?.() || pane.props.label\n        const tabindex = !disabled && pane.active ? 0 : -1\n\n        return (\n          <div\n            ref={`tab-${uid}`}\n            class={[\n              ns.e('item'),\n              ns.is(rootTabs.props.tabPosition),\n              ns.is('active', pane.active),\n              ns.is('disabled', disabled),\n              ns.is('closable', closable),\n              ns.is('focus', isFocus.value),\n            ]}\n            id={`tab-${tabName}`}\n            key={`tab-${uid}`}\n            aria-controls={`pane-${tabName}`}\n            role=\"tab\"\n            aria-selected={pane.active}\n            tabindex={tabindex}\n            onFocus={() => setFocus()}\n            onBlur={() => removeFocus()}\n            onClick={(ev: MouseEvent) => {\n              removeFocus()\n              emit('tabClick', pane, tabName, ev)\n            }}\n            onKeydown={(ev: KeyboardEvent) => {\n              if (\n                closable &&\n                (ev.code === EVENT_CODE.delete ||\n                  ev.code === EVENT_CODE.backspace)\n              ) {\n                emit('tabRemove', pane, ev)\n              }\n            }}\n          >\n            {...[tabLabelContent, btnClose]}\n          </div>\n        )\n      })\n\n      return (\n        <div\n          ref={el$}\n          class={[\n            ns.e('nav-wrap'),\n            ns.is('scrollable', !!scrollable.value),\n            ns.is(rootTabs.props.tabPosition),\n          ]}\n        >\n          {scrollBtn}\n          <div class={ns.e('nav-scroll')} ref={navScroll$}>\n            <div\n              class={[\n                ns.e('nav'),\n                ns.is(rootTabs.props.tabPosition),\n                ns.is(\n                  'stretch',\n                  props.stretch &&\n                    ['top', 'bottom'].includes(rootTabs.props.tabPosition)\n                ),\n              ]}\n              ref={nav$}\n              style={navStyle.value}\n              role=\"tablist\"\n              onKeydown={changeTab}\n            >\n              {...[\n                !props.type ? (\n                  <TabBar ref={tabBarRef} tabs={[...props.panes]} />\n                ) : null,\n                tabs,\n              ]}\n            </div>\n          </div>\n        </div>\n      )\n    }\n  },\n})\n\nexport type TabNavInstance = InstanceType<typeof TabNav>\nexport default TabNav\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}